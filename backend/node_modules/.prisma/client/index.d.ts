
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Parque
 * 
 */
export type Parque = {
  id: number
  nombre: string
  descripcion: string
  imagen: string
  direccion: string
  latitud: number
  longitud: number
  fechaDecreto: string
  superficieTerrestre: number
  superficieMarina: number
  clicks: number
}

/**
 * Model Estado
 * 
 */
export type Estado = {
  id: number
  nombre: string
}

/**
 * Model EstadoParque
 * 
 */
export type EstadoParque = {
  parqueId: number
  estadoId: number
  assignedAt: Date
  assignedBy: string
}

/**
 * Model Region
 * 
 */
export type Region = {
  id: number
  nombre: string
}

/**
 * Model RegionParque
 * 
 */
export type RegionParque = {
  parqueId: number
  regionId: number
  assignedAt: Date
  assignedBy: string
}

/**
 * Model Categoria
 * 
 */
export type Categoria = {
  id: number
  nombre: string
}

/**
 * Model CategoriaParque
 * 
 */
export type CategoriaParque = {
  parqueId: number
  categoriaId: number
  assignedAt: Date
  assignedBy: string
}

/**
 * Model Flora
 * 
 */
export type Flora = {
  id: number
  nombre: string
  imagen: string
  descripcion: string
}

/**
 * Model FloraParque
 * 
 */
export type FloraParque = {
  parqueId: number
  floraId: number
  assignedAt: Date
  assignedBy: string
}

/**
 * Model Fauna
 * 
 */
export type Fauna = {
  id: number
  nombre: string
  imagen: string
  descripcion: string
}

/**
 * Model FaunaParque
 * 
 */
export type FaunaParque = {
  parqueId: number
  faunaID: number
  assignedAt: Date
  assignedBy: string
}

/**
 * Model Actividad
 * 
 */
export type Actividad = {
  id: number
  nombre: string
}

/**
 * Model ActividadParque
 * 
 */
export type ActividadParque = {
  parqueId: number
  actividadId: number
  assignedAt: Date
  assignedBy: string
}

/**
 * Model Anuncio
 * 
 */
export type Anuncio = {
  id: number
  titulo: string
  descripcion: string
  variante: string
  parqueId: number
}

/**
 * Model Horario
 * 
 */
export type Horario = {
  id: number
  dias: string
  horaAbrir: string
  horaCerrar: string
  parqueId: number
}

/**
 * Model Usuario
 * 
 */
export type Usuario = {
  id: number
  nombre: string
  email: string
  password: string
  role: Role
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Parques
 * const parques = await prisma.parque.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Parques
   * const parques = await prisma.parque.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.parque`: Exposes CRUD operations for the **Parque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parques
    * const parques = await prisma.parque.findMany()
    * ```
    */
  get parque(): Prisma.ParqueDelegate<GlobalReject>;

  /**
   * `prisma.estado`: Exposes CRUD operations for the **Estado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estado.findMany()
    * ```
    */
  get estado(): Prisma.EstadoDelegate<GlobalReject>;

  /**
   * `prisma.estadoParque`: Exposes CRUD operations for the **EstadoParque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstadoParques
    * const estadoParques = await prisma.estadoParque.findMany()
    * ```
    */
  get estadoParque(): Prisma.EstadoParqueDelegate<GlobalReject>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<GlobalReject>;

  /**
   * `prisma.regionParque`: Exposes CRUD operations for the **RegionParque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionParques
    * const regionParques = await prisma.regionParque.findMany()
    * ```
    */
  get regionParque(): Prisma.RegionParqueDelegate<GlobalReject>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<GlobalReject>;

  /**
   * `prisma.categoriaParque`: Exposes CRUD operations for the **CategoriaParque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriaParques
    * const categoriaParques = await prisma.categoriaParque.findMany()
    * ```
    */
  get categoriaParque(): Prisma.CategoriaParqueDelegate<GlobalReject>;

  /**
   * `prisma.flora`: Exposes CRUD operations for the **Flora** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Floras
    * const floras = await prisma.flora.findMany()
    * ```
    */
  get flora(): Prisma.FloraDelegate<GlobalReject>;

  /**
   * `prisma.floraParque`: Exposes CRUD operations for the **FloraParque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FloraParques
    * const floraParques = await prisma.floraParque.findMany()
    * ```
    */
  get floraParque(): Prisma.FloraParqueDelegate<GlobalReject>;

  /**
   * `prisma.fauna`: Exposes CRUD operations for the **Fauna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faunas
    * const faunas = await prisma.fauna.findMany()
    * ```
    */
  get fauna(): Prisma.FaunaDelegate<GlobalReject>;

  /**
   * `prisma.faunaParque`: Exposes CRUD operations for the **FaunaParque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FaunaParques
    * const faunaParques = await prisma.faunaParque.findMany()
    * ```
    */
  get faunaParque(): Prisma.FaunaParqueDelegate<GlobalReject>;

  /**
   * `prisma.actividad`: Exposes CRUD operations for the **Actividad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actividads
    * const actividads = await prisma.actividad.findMany()
    * ```
    */
  get actividad(): Prisma.ActividadDelegate<GlobalReject>;

  /**
   * `prisma.actividadParque`: Exposes CRUD operations for the **ActividadParque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActividadParques
    * const actividadParques = await prisma.actividadParque.findMany()
    * ```
    */
  get actividadParque(): Prisma.ActividadParqueDelegate<GlobalReject>;

  /**
   * `prisma.anuncio`: Exposes CRUD operations for the **Anuncio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anuncios
    * const anuncios = await prisma.anuncio.findMany()
    * ```
    */
  get anuncio(): Prisma.AnuncioDelegate<GlobalReject>;

  /**
   * `prisma.horario`: Exposes CRUD operations for the **Horario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horarios
    * const horarios = await prisma.horario.findMany()
    * ```
    */
  get horario(): Prisma.HorarioDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.14.0
   * Query Engine version: 2b0c12756921c891fec4f68d9444e18c7d5d4a6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Parque: 'Parque',
    Estado: 'Estado',
    EstadoParque: 'EstadoParque',
    Region: 'Region',
    RegionParque: 'RegionParque',
    Categoria: 'Categoria',
    CategoriaParque: 'CategoriaParque',
    Flora: 'Flora',
    FloraParque: 'FloraParque',
    Fauna: 'Fauna',
    FaunaParque: 'FaunaParque',
    Actividad: 'Actividad',
    ActividadParque: 'ActividadParque',
    Anuncio: 'Anuncio',
    Horario: 'Horario',
    Usuario: 'Usuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ParqueCountOutputType
   */


  export type ParqueCountOutputType = {
    anuncios: number
    horario: number
    actividades: number
    flora: number
    fauna: number
    categoria: number
    estado: number
    region: number
  }

  export type ParqueCountOutputTypeSelect = {
    anuncios?: boolean
    horario?: boolean
    actividades?: boolean
    flora?: boolean
    fauna?: boolean
    categoria?: boolean
    estado?: boolean
    region?: boolean
  }

  export type ParqueCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ParqueCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ParqueCountOutputType
    : S extends undefined
    ? never
    : S extends ParqueCountOutputTypeArgs
    ?'include' extends U
    ? ParqueCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ParqueCountOutputType ? ParqueCountOutputType[P] : never
  } 
    : ParqueCountOutputType
  : ParqueCountOutputType




  // Custom InputTypes

  /**
   * ParqueCountOutputType without action
   */
  export type ParqueCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ParqueCountOutputType
     * 
    **/
    select?: ParqueCountOutputTypeSelect | null
  }



  /**
   * Count Type EstadoCountOutputType
   */


  export type EstadoCountOutputType = {
    parque: number
  }

  export type EstadoCountOutputTypeSelect = {
    parque?: boolean
  }

  export type EstadoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EstadoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EstadoCountOutputType
    : S extends undefined
    ? never
    : S extends EstadoCountOutputTypeArgs
    ?'include' extends U
    ? EstadoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EstadoCountOutputType ? EstadoCountOutputType[P] : never
  } 
    : EstadoCountOutputType
  : EstadoCountOutputType




  // Custom InputTypes

  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EstadoCountOutputType
     * 
    **/
    select?: EstadoCountOutputTypeSelect | null
  }



  /**
   * Count Type RegionCountOutputType
   */


  export type RegionCountOutputType = {
    parque: number
  }

  export type RegionCountOutputTypeSelect = {
    parque?: boolean
  }

  export type RegionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RegionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RegionCountOutputType
    : S extends undefined
    ? never
    : S extends RegionCountOutputTypeArgs
    ?'include' extends U
    ? RegionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RegionCountOutputType ? RegionCountOutputType[P] : never
  } 
    : RegionCountOutputType
  : RegionCountOutputType




  // Custom InputTypes

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     * 
    **/
    select?: RegionCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoriaCountOutputType
   */


  export type CategoriaCountOutputType = {
    parque: number
  }

  export type CategoriaCountOutputTypeSelect = {
    parque?: boolean
  }

  export type CategoriaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoriaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoriaCountOutputType
    : S extends undefined
    ? never
    : S extends CategoriaCountOutputTypeArgs
    ?'include' extends U
    ? CategoriaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoriaCountOutputType ? CategoriaCountOutputType[P] : never
  } 
    : CategoriaCountOutputType
  : CategoriaCountOutputType




  // Custom InputTypes

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     * 
    **/
    select?: CategoriaCountOutputTypeSelect | null
  }



  /**
   * Count Type FloraCountOutputType
   */


  export type FloraCountOutputType = {
    parques: number
  }

  export type FloraCountOutputTypeSelect = {
    parques?: boolean
  }

  export type FloraCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FloraCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FloraCountOutputType
    : S extends undefined
    ? never
    : S extends FloraCountOutputTypeArgs
    ?'include' extends U
    ? FloraCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FloraCountOutputType ? FloraCountOutputType[P] : never
  } 
    : FloraCountOutputType
  : FloraCountOutputType




  // Custom InputTypes

  /**
   * FloraCountOutputType without action
   */
  export type FloraCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FloraCountOutputType
     * 
    **/
    select?: FloraCountOutputTypeSelect | null
  }



  /**
   * Count Type FaunaCountOutputType
   */


  export type FaunaCountOutputType = {
    parques: number
  }

  export type FaunaCountOutputTypeSelect = {
    parques?: boolean
  }

  export type FaunaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FaunaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FaunaCountOutputType
    : S extends undefined
    ? never
    : S extends FaunaCountOutputTypeArgs
    ?'include' extends U
    ? FaunaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FaunaCountOutputType ? FaunaCountOutputType[P] : never
  } 
    : FaunaCountOutputType
  : FaunaCountOutputType




  // Custom InputTypes

  /**
   * FaunaCountOutputType without action
   */
  export type FaunaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FaunaCountOutputType
     * 
    **/
    select?: FaunaCountOutputTypeSelect | null
  }



  /**
   * Count Type ActividadCountOutputType
   */


  export type ActividadCountOutputType = {
    parques: number
  }

  export type ActividadCountOutputTypeSelect = {
    parques?: boolean
  }

  export type ActividadCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ActividadCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ActividadCountOutputType
    : S extends undefined
    ? never
    : S extends ActividadCountOutputTypeArgs
    ?'include' extends U
    ? ActividadCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ActividadCountOutputType ? ActividadCountOutputType[P] : never
  } 
    : ActividadCountOutputType
  : ActividadCountOutputType




  // Custom InputTypes

  /**
   * ActividadCountOutputType without action
   */
  export type ActividadCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ActividadCountOutputType
     * 
    **/
    select?: ActividadCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Parque
   */


  export type AggregateParque = {
    _count: ParqueCountAggregateOutputType | null
    _avg: ParqueAvgAggregateOutputType | null
    _sum: ParqueSumAggregateOutputType | null
    _min: ParqueMinAggregateOutputType | null
    _max: ParqueMaxAggregateOutputType | null
  }

  export type ParqueAvgAggregateOutputType = {
    id: number | null
    latitud: number | null
    longitud: number | null
    superficieTerrestre: number | null
    superficieMarina: number | null
    clicks: number | null
  }

  export type ParqueSumAggregateOutputType = {
    id: number | null
    latitud: number | null
    longitud: number | null
    superficieTerrestre: number | null
    superficieMarina: number | null
    clicks: number | null
  }

  export type ParqueMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    imagen: string | null
    direccion: string | null
    latitud: number | null
    longitud: number | null
    fechaDecreto: string | null
    superficieTerrestre: number | null
    superficieMarina: number | null
    clicks: number | null
  }

  export type ParqueMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    imagen: string | null
    direccion: string | null
    latitud: number | null
    longitud: number | null
    fechaDecreto: string | null
    superficieTerrestre: number | null
    superficieMarina: number | null
    clicks: number | null
  }

  export type ParqueCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    imagen: number
    direccion: number
    latitud: number
    longitud: number
    fechaDecreto: number
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    _all: number
  }


  export type ParqueAvgAggregateInputType = {
    id?: true
    latitud?: true
    longitud?: true
    superficieTerrestre?: true
    superficieMarina?: true
    clicks?: true
  }

  export type ParqueSumAggregateInputType = {
    id?: true
    latitud?: true
    longitud?: true
    superficieTerrestre?: true
    superficieMarina?: true
    clicks?: true
  }

  export type ParqueMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    imagen?: true
    direccion?: true
    latitud?: true
    longitud?: true
    fechaDecreto?: true
    superficieTerrestre?: true
    superficieMarina?: true
    clicks?: true
  }

  export type ParqueMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    imagen?: true
    direccion?: true
    latitud?: true
    longitud?: true
    fechaDecreto?: true
    superficieTerrestre?: true
    superficieMarina?: true
    clicks?: true
  }

  export type ParqueCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    imagen?: true
    direccion?: true
    latitud?: true
    longitud?: true
    fechaDecreto?: true
    superficieTerrestre?: true
    superficieMarina?: true
    clicks?: true
    _all?: true
  }

  export type ParqueAggregateArgs = {
    /**
     * Filter which Parque to aggregate.
     * 
    **/
    where?: ParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parques to fetch.
     * 
    **/
    orderBy?: Enumerable<ParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parques
    **/
    _count?: true | ParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParqueMaxAggregateInputType
  }

  export type GetParqueAggregateType<T extends ParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParque[P]>
      : GetScalarType<T[P], AggregateParque[P]>
  }




  export type ParqueGroupByArgs = {
    where?: ParqueWhereInput
    orderBy?: Enumerable<ParqueOrderByWithAggregationInput>
    by: Array<ParqueScalarFieldEnum>
    having?: ParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParqueCountAggregateInputType | true
    _avg?: ParqueAvgAggregateInputType
    _sum?: ParqueSumAggregateInputType
    _min?: ParqueMinAggregateInputType
    _max?: ParqueMaxAggregateInputType
  }


  export type ParqueGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    _count: ParqueCountAggregateOutputType | null
    _avg: ParqueAvgAggregateOutputType | null
    _sum: ParqueSumAggregateOutputType | null
    _min: ParqueMinAggregateOutputType | null
    _max: ParqueMaxAggregateOutputType | null
  }

  type GetParqueGroupByPayload<T extends ParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParqueGroupByOutputType[P]>
            : GetScalarType<T[P], ParqueGroupByOutputType[P]>
        }
      >
    >


  export type ParqueSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    imagen?: boolean
    direccion?: boolean
    latitud?: boolean
    longitud?: boolean
    fechaDecreto?: boolean
    superficieTerrestre?: boolean
    superficieMarina?: boolean
    clicks?: boolean
    anuncios?: boolean | AnuncioFindManyArgs
    horario?: boolean | HorarioFindManyArgs
    actividades?: boolean | ActividadParqueFindManyArgs
    flora?: boolean | FloraParqueFindManyArgs
    fauna?: boolean | FaunaParqueFindManyArgs
    categoria?: boolean | CategoriaParqueFindManyArgs
    estado?: boolean | EstadoParqueFindManyArgs
    region?: boolean | RegionParqueFindManyArgs
    _count?: boolean | ParqueCountOutputTypeArgs
  }

  export type ParqueInclude = {
    anuncios?: boolean | AnuncioFindManyArgs
    horario?: boolean | HorarioFindManyArgs
    actividades?: boolean | ActividadParqueFindManyArgs
    flora?: boolean | FloraParqueFindManyArgs
    fauna?: boolean | FaunaParqueFindManyArgs
    categoria?: boolean | CategoriaParqueFindManyArgs
    estado?: boolean | EstadoParqueFindManyArgs
    region?: boolean | RegionParqueFindManyArgs
    _count?: boolean | ParqueCountOutputTypeArgs
  }

  export type ParqueGetPayload<
    S extends boolean | null | undefined | ParqueArgs,
    U = keyof S
      > = S extends true
        ? Parque
    : S extends undefined
    ? never
    : S extends ParqueArgs | ParqueFindManyArgs
    ?'include' extends U
    ? Parque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'anuncios' ? Array < AnuncioGetPayload<S['include'][P]>>  :
        P extends 'horario' ? Array < HorarioGetPayload<S['include'][P]>>  :
        P extends 'actividades' ? Array < ActividadParqueGetPayload<S['include'][P]>>  :
        P extends 'flora' ? Array < FloraParqueGetPayload<S['include'][P]>>  :
        P extends 'fauna' ? Array < FaunaParqueGetPayload<S['include'][P]>>  :
        P extends 'categoria' ? Array < CategoriaParqueGetPayload<S['include'][P]>>  :
        P extends 'estado' ? Array < EstadoParqueGetPayload<S['include'][P]>>  :
        P extends 'region' ? Array < RegionParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? ParqueCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'anuncios' ? Array < AnuncioGetPayload<S['select'][P]>>  :
        P extends 'horario' ? Array < HorarioGetPayload<S['select'][P]>>  :
        P extends 'actividades' ? Array < ActividadParqueGetPayload<S['select'][P]>>  :
        P extends 'flora' ? Array < FloraParqueGetPayload<S['select'][P]>>  :
        P extends 'fauna' ? Array < FaunaParqueGetPayload<S['select'][P]>>  :
        P extends 'categoria' ? Array < CategoriaParqueGetPayload<S['select'][P]>>  :
        P extends 'estado' ? Array < EstadoParqueGetPayload<S['select'][P]>>  :
        P extends 'region' ? Array < RegionParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? ParqueCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Parque ? Parque[P] : never
  } 
    : Parque
  : Parque


  type ParqueCountArgs = Merge<
    Omit<ParqueFindManyArgs, 'select' | 'include'> & {
      select?: ParqueCountAggregateInputType | true
    }
  >

  export interface ParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Parque that matches the filter.
     * @param {ParqueFindUniqueArgs} args - Arguments to find a Parque
     * @example
     * // Get one Parque
     * const parque = await prisma.parque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Parque'> extends True ? CheckSelect<T, Prisma__ParqueClient<Parque>, Prisma__ParqueClient<ParqueGetPayload<T>>> : CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>

    /**
     * Find the first Parque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParqueFindFirstArgs} args - Arguments to find a Parque
     * @example
     * // Get one Parque
     * const parque = await prisma.parque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Parque'> extends True ? CheckSelect<T, Prisma__ParqueClient<Parque>, Prisma__ParqueClient<ParqueGetPayload<T>>> : CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>

    /**
     * Find zero or more Parques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parques
     * const parques = await prisma.parque.findMany()
     * 
     * // Get first 10 Parques
     * const parques = await prisma.parque.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parqueWithIdOnly = await prisma.parque.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParqueFindManyArgs>(
      args?: SelectSubset<T, ParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Parque>>, PrismaPromise<Array<ParqueGetPayload<T>>>>

    /**
     * Create a Parque.
     * @param {ParqueCreateArgs} args - Arguments to create a Parque.
     * @example
     * // Create one Parque
     * const Parque = await prisma.parque.create({
     *   data: {
     *     // ... data to create a Parque
     *   }
     * })
     * 
    **/
    create<T extends ParqueCreateArgs>(
      args: SelectSubset<T, ParqueCreateArgs>
    ): CheckSelect<T, Prisma__ParqueClient<Parque>, Prisma__ParqueClient<ParqueGetPayload<T>>>

    /**
     * Create many Parques.
     *     @param {ParqueCreateManyArgs} args - Arguments to create many Parques.
     *     @example
     *     // Create many Parques
     *     const parque = await prisma.parque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParqueCreateManyArgs>(
      args?: SelectSubset<T, ParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Parque.
     * @param {ParqueDeleteArgs} args - Arguments to delete one Parque.
     * @example
     * // Delete one Parque
     * const Parque = await prisma.parque.delete({
     *   where: {
     *     // ... filter to delete one Parque
     *   }
     * })
     * 
    **/
    delete<T extends ParqueDeleteArgs>(
      args: SelectSubset<T, ParqueDeleteArgs>
    ): CheckSelect<T, Prisma__ParqueClient<Parque>, Prisma__ParqueClient<ParqueGetPayload<T>>>

    /**
     * Update one Parque.
     * @param {ParqueUpdateArgs} args - Arguments to update one Parque.
     * @example
     * // Update one Parque
     * const parque = await prisma.parque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParqueUpdateArgs>(
      args: SelectSubset<T, ParqueUpdateArgs>
    ): CheckSelect<T, Prisma__ParqueClient<Parque>, Prisma__ParqueClient<ParqueGetPayload<T>>>

    /**
     * Delete zero or more Parques.
     * @param {ParqueDeleteManyArgs} args - Arguments to filter Parques to delete.
     * @example
     * // Delete a few Parques
     * const { count } = await prisma.parque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParqueDeleteManyArgs>(
      args?: SelectSubset<T, ParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parques
     * const parque = await prisma.parque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParqueUpdateManyArgs>(
      args: SelectSubset<T, ParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Parque.
     * @param {ParqueUpsertArgs} args - Arguments to update or create a Parque.
     * @example
     * // Update or create a Parque
     * const parque = await prisma.parque.upsert({
     *   create: {
     *     // ... data to create a Parque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parque we want to update
     *   }
     * })
    **/
    upsert<T extends ParqueUpsertArgs>(
      args: SelectSubset<T, ParqueUpsertArgs>
    ): CheckSelect<T, Prisma__ParqueClient<Parque>, Prisma__ParqueClient<ParqueGetPayload<T>>>

    /**
     * Count the number of Parques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParqueCountArgs} args - Arguments to filter Parques to count.
     * @example
     * // Count the number of Parques
     * const count = await prisma.parque.count({
     *   where: {
     *     // ... the filter for the Parques we want to count
     *   }
     * })
    **/
    count<T extends ParqueCountArgs>(
      args?: Subset<T, ParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParqueAggregateArgs>(args: Subset<T, ParqueAggregateArgs>): PrismaPromise<GetParqueAggregateType<T>>

    /**
     * Group by Parque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParqueGroupByArgs['orderBy'] }
        : { orderBy?: ParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    anuncios<T extends AnuncioFindManyArgs = {}>(args?: Subset<T, AnuncioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Anuncio>>, PrismaPromise<Array<AnuncioGetPayload<T>>>>;

    horario<T extends HorarioFindManyArgs = {}>(args?: Subset<T, HorarioFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Horario>>, PrismaPromise<Array<HorarioGetPayload<T>>>>;

    actividades<T extends ActividadParqueFindManyArgs = {}>(args?: Subset<T, ActividadParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ActividadParque>>, PrismaPromise<Array<ActividadParqueGetPayload<T>>>>;

    flora<T extends FloraParqueFindManyArgs = {}>(args?: Subset<T, FloraParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FloraParque>>, PrismaPromise<Array<FloraParqueGetPayload<T>>>>;

    fauna<T extends FaunaParqueFindManyArgs = {}>(args?: Subset<T, FaunaParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FaunaParque>>, PrismaPromise<Array<FaunaParqueGetPayload<T>>>>;

    categoria<T extends CategoriaParqueFindManyArgs = {}>(args?: Subset<T, CategoriaParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CategoriaParque>>, PrismaPromise<Array<CategoriaParqueGetPayload<T>>>>;

    estado<T extends EstadoParqueFindManyArgs = {}>(args?: Subset<T, EstadoParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EstadoParque>>, PrismaPromise<Array<EstadoParqueGetPayload<T>>>>;

    region<T extends RegionParqueFindManyArgs = {}>(args?: Subset<T, RegionParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RegionParque>>, PrismaPromise<Array<RegionParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Parque findUnique
   */
  export type ParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * Throw an Error if a Parque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Parque to fetch.
     * 
    **/
    where: ParqueWhereUniqueInput
  }


  /**
   * Parque findFirst
   */
  export type ParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * Throw an Error if a Parque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Parque to fetch.
     * 
    **/
    where?: ParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parques to fetch.
     * 
    **/
    orderBy?: Enumerable<ParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parques.
     * 
    **/
    cursor?: ParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parques.
     * 
    **/
    distinct?: Enumerable<ParqueScalarFieldEnum>
  }


  /**
   * Parque findMany
   */
  export type ParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * Filter, which Parques to fetch.
     * 
    **/
    where?: ParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parques to fetch.
     * 
    **/
    orderBy?: Enumerable<ParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parques.
     * 
    **/
    cursor?: ParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ParqueScalarFieldEnum>
  }


  /**
   * Parque create
   */
  export type ParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * The data needed to create a Parque.
     * 
    **/
    data: XOR<ParqueCreateInput, ParqueUncheckedCreateInput>
  }


  /**
   * Parque createMany
   */
  export type ParqueCreateManyArgs = {
    /**
     * The data used to create many Parques.
     * 
    **/
    data: Enumerable<ParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Parque update
   */
  export type ParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * The data needed to update a Parque.
     * 
    **/
    data: XOR<ParqueUpdateInput, ParqueUncheckedUpdateInput>
    /**
     * Choose, which Parque to update.
     * 
    **/
    where: ParqueWhereUniqueInput
  }


  /**
   * Parque updateMany
   */
  export type ParqueUpdateManyArgs = {
    /**
     * The data used to update Parques.
     * 
    **/
    data: XOR<ParqueUpdateManyMutationInput, ParqueUncheckedUpdateManyInput>
    /**
     * Filter which Parques to update
     * 
    **/
    where?: ParqueWhereInput
  }


  /**
   * Parque upsert
   */
  export type ParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * The filter to search for the Parque to update in case it exists.
     * 
    **/
    where: ParqueWhereUniqueInput
    /**
     * In case the Parque found by the `where` argument doesn't exist, create a new Parque with this data.
     * 
    **/
    create: XOR<ParqueCreateInput, ParqueUncheckedCreateInput>
    /**
     * In case the Parque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ParqueUpdateInput, ParqueUncheckedUpdateInput>
  }


  /**
   * Parque delete
   */
  export type ParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
    /**
     * Filter which Parque to delete.
     * 
    **/
    where: ParqueWhereUniqueInput
  }


  /**
   * Parque deleteMany
   */
  export type ParqueDeleteManyArgs = {
    /**
     * Filter which Parques to delete
     * 
    **/
    where?: ParqueWhereInput
  }


  /**
   * Parque without action
   */
  export type ParqueArgs = {
    /**
     * Select specific fields to fetch from the Parque
     * 
    **/
    select?: ParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParqueInclude | null
  }



  /**
   * Model Estado
   */


  export type AggregateEstado = {
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  export type EstadoAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EstadoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EstadoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type EstadoAvgAggregateInputType = {
    id?: true
  }

  export type EstadoSumAggregateInputType = {
    id?: true
  }

  export type EstadoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EstadoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EstadoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type EstadoAggregateArgs = {
    /**
     * Filter which Estado to aggregate.
     * 
    **/
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estados
    **/
    _count?: true | EstadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoMaxAggregateInputType
  }

  export type GetEstadoAggregateType<T extends EstadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstado[P]>
      : GetScalarType<T[P], AggregateEstado[P]>
  }




  export type EstadoGroupByArgs = {
    where?: EstadoWhereInput
    orderBy?: Enumerable<EstadoOrderByWithAggregationInput>
    by: Array<EstadoScalarFieldEnum>
    having?: EstadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCountAggregateInputType | true
    _avg?: EstadoAvgAggregateInputType
    _sum?: EstadoSumAggregateInputType
    _min?: EstadoMinAggregateInputType
    _max?: EstadoMaxAggregateInputType
  }


  export type EstadoGroupByOutputType = {
    id: number
    nombre: string
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  type GetEstadoGroupByPayload<T extends EstadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EstadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoGroupByOutputType[P]>
        }
      >
    >


  export type EstadoSelect = {
    id?: boolean
    nombre?: boolean
    parque?: boolean | EstadoParqueFindManyArgs
    _count?: boolean | EstadoCountOutputTypeArgs
  }

  export type EstadoInclude = {
    parque?: boolean | EstadoParqueFindManyArgs
    _count?: boolean | EstadoCountOutputTypeArgs
  }

  export type EstadoGetPayload<
    S extends boolean | null | undefined | EstadoArgs,
    U = keyof S
      > = S extends true
        ? Estado
    : S extends undefined
    ? never
    : S extends EstadoArgs | EstadoFindManyArgs
    ?'include' extends U
    ? Estado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? Array < EstadoParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? EstadoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? Array < EstadoParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? EstadoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Estado ? Estado[P] : never
  } 
    : Estado
  : Estado


  type EstadoCountArgs = Merge<
    Omit<EstadoFindManyArgs, 'select' | 'include'> & {
      select?: EstadoCountAggregateInputType | true
    }
  >

  export interface EstadoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Estado that matches the filter.
     * @param {EstadoFindUniqueArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EstadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Estado'> extends True ? CheckSelect<T, Prisma__EstadoClient<Estado>, Prisma__EstadoClient<EstadoGetPayload<T>>> : CheckSelect<T, Prisma__EstadoClient<Estado | null >, Prisma__EstadoClient<EstadoGetPayload<T> | null >>

    /**
     * Find the first Estado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindFirstArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EstadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Estado'> extends True ? CheckSelect<T, Prisma__EstadoClient<Estado>, Prisma__EstadoClient<EstadoGetPayload<T>>> : CheckSelect<T, Prisma__EstadoClient<Estado | null >, Prisma__EstadoClient<EstadoGetPayload<T> | null >>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estado.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoWithIdOnly = await prisma.estado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EstadoFindManyArgs>(
      args?: SelectSubset<T, EstadoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Estado>>, PrismaPromise<Array<EstadoGetPayload<T>>>>

    /**
     * Create a Estado.
     * @param {EstadoCreateArgs} args - Arguments to create a Estado.
     * @example
     * // Create one Estado
     * const Estado = await prisma.estado.create({
     *   data: {
     *     // ... data to create a Estado
     *   }
     * })
     * 
    **/
    create<T extends EstadoCreateArgs>(
      args: SelectSubset<T, EstadoCreateArgs>
    ): CheckSelect<T, Prisma__EstadoClient<Estado>, Prisma__EstadoClient<EstadoGetPayload<T>>>

    /**
     * Create many Estados.
     *     @param {EstadoCreateManyArgs} args - Arguments to create many Estados.
     *     @example
     *     // Create many Estados
     *     const estado = await prisma.estado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoCreateManyArgs>(
      args?: SelectSubset<T, EstadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Estado.
     * @param {EstadoDeleteArgs} args - Arguments to delete one Estado.
     * @example
     * // Delete one Estado
     * const Estado = await prisma.estado.delete({
     *   where: {
     *     // ... filter to delete one Estado
     *   }
     * })
     * 
    **/
    delete<T extends EstadoDeleteArgs>(
      args: SelectSubset<T, EstadoDeleteArgs>
    ): CheckSelect<T, Prisma__EstadoClient<Estado>, Prisma__EstadoClient<EstadoGetPayload<T>>>

    /**
     * Update one Estado.
     * @param {EstadoUpdateArgs} args - Arguments to update one Estado.
     * @example
     * // Update one Estado
     * const estado = await prisma.estado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoUpdateArgs>(
      args: SelectSubset<T, EstadoUpdateArgs>
    ): CheckSelect<T, Prisma__EstadoClient<Estado>, Prisma__EstadoClient<EstadoGetPayload<T>>>

    /**
     * Delete zero or more Estados.
     * @param {EstadoDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoDeleteManyArgs>(
      args?: SelectSubset<T, EstadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estado = await prisma.estado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoUpdateManyArgs>(
      args: SelectSubset<T, EstadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Estado.
     * @param {EstadoUpsertArgs} args - Arguments to update or create a Estado.
     * @example
     * // Update or create a Estado
     * const estado = await prisma.estado.upsert({
     *   create: {
     *     // ... data to create a Estado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estado we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoUpsertArgs>(
      args: SelectSubset<T, EstadoUpsertArgs>
    ): CheckSelect<T, Prisma__EstadoClient<Estado>, Prisma__EstadoClient<EstadoGetPayload<T>>>

    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estado.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends EstadoCountArgs>(
      args?: Subset<T, EstadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoAggregateArgs>(args: Subset<T, EstadoAggregateArgs>): PrismaPromise<GetEstadoAggregateType<T>>

    /**
     * Group by Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoGroupByArgs['orderBy'] }
        : { orderBy?: EstadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EstadoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends EstadoParqueFindManyArgs = {}>(args?: Subset<T, EstadoParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EstadoParque>>, PrismaPromise<Array<EstadoParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Estado findUnique
   */
  export type EstadoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * Throw an Error if a Estado can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Estado to fetch.
     * 
    **/
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado findFirst
   */
  export type EstadoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * Throw an Error if a Estado can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Estado to fetch.
     * 
    **/
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estados.
     * 
    **/
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estados.
     * 
    **/
    distinct?: Enumerable<EstadoScalarFieldEnum>
  }


  /**
   * Estado findMany
   */
  export type EstadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * Filter, which Estados to fetch.
     * 
    **/
    where?: EstadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estados to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estados.
     * 
    **/
    cursor?: EstadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EstadoScalarFieldEnum>
  }


  /**
   * Estado create
   */
  export type EstadoCreateArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * The data needed to create a Estado.
     * 
    **/
    data: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
  }


  /**
   * Estado createMany
   */
  export type EstadoCreateManyArgs = {
    /**
     * The data used to create many Estados.
     * 
    **/
    data: Enumerable<EstadoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Estado update
   */
  export type EstadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * The data needed to update a Estado.
     * 
    **/
    data: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
    /**
     * Choose, which Estado to update.
     * 
    **/
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado updateMany
   */
  export type EstadoUpdateManyArgs = {
    /**
     * The data used to update Estados.
     * 
    **/
    data: XOR<EstadoUpdateManyMutationInput, EstadoUncheckedUpdateManyInput>
    /**
     * Filter which Estados to update
     * 
    **/
    where?: EstadoWhereInput
  }


  /**
   * Estado upsert
   */
  export type EstadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * The filter to search for the Estado to update in case it exists.
     * 
    **/
    where: EstadoWhereUniqueInput
    /**
     * In case the Estado found by the `where` argument doesn't exist, create a new Estado with this data.
     * 
    **/
    create: XOR<EstadoCreateInput, EstadoUncheckedCreateInput>
    /**
     * In case the Estado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EstadoUpdateInput, EstadoUncheckedUpdateInput>
  }


  /**
   * Estado delete
   */
  export type EstadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
    /**
     * Filter which Estado to delete.
     * 
    **/
    where: EstadoWhereUniqueInput
  }


  /**
   * Estado deleteMany
   */
  export type EstadoDeleteManyArgs = {
    /**
     * Filter which Estados to delete
     * 
    **/
    where?: EstadoWhereInput
  }


  /**
   * Estado without action
   */
  export type EstadoArgs = {
    /**
     * Select specific fields to fetch from the Estado
     * 
    **/
    select?: EstadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoInclude | null
  }



  /**
   * Model EstadoParque
   */


  export type AggregateEstadoParque = {
    _count: EstadoParqueCountAggregateOutputType | null
    _avg: EstadoParqueAvgAggregateOutputType | null
    _sum: EstadoParqueSumAggregateOutputType | null
    _min: EstadoParqueMinAggregateOutputType | null
    _max: EstadoParqueMaxAggregateOutputType | null
  }

  export type EstadoParqueAvgAggregateOutputType = {
    parqueId: number | null
    estadoId: number | null
  }

  export type EstadoParqueSumAggregateOutputType = {
    parqueId: number | null
    estadoId: number | null
  }

  export type EstadoParqueMinAggregateOutputType = {
    parqueId: number | null
    estadoId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type EstadoParqueMaxAggregateOutputType = {
    parqueId: number | null
    estadoId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type EstadoParqueCountAggregateOutputType = {
    parqueId: number
    estadoId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type EstadoParqueAvgAggregateInputType = {
    parqueId?: true
    estadoId?: true
  }

  export type EstadoParqueSumAggregateInputType = {
    parqueId?: true
    estadoId?: true
  }

  export type EstadoParqueMinAggregateInputType = {
    parqueId?: true
    estadoId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type EstadoParqueMaxAggregateInputType = {
    parqueId?: true
    estadoId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type EstadoParqueCountAggregateInputType = {
    parqueId?: true
    estadoId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type EstadoParqueAggregateArgs = {
    /**
     * Filter which EstadoParque to aggregate.
     * 
    **/
    where?: EstadoParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoParques to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EstadoParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EstadoParques
    **/
    _count?: true | EstadoParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoParqueMaxAggregateInputType
  }

  export type GetEstadoParqueAggregateType<T extends EstadoParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateEstadoParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstadoParque[P]>
      : GetScalarType<T[P], AggregateEstadoParque[P]>
  }




  export type EstadoParqueGroupByArgs = {
    where?: EstadoParqueWhereInput
    orderBy?: Enumerable<EstadoParqueOrderByWithAggregationInput>
    by: Array<EstadoParqueScalarFieldEnum>
    having?: EstadoParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoParqueCountAggregateInputType | true
    _avg?: EstadoParqueAvgAggregateInputType
    _sum?: EstadoParqueSumAggregateInputType
    _min?: EstadoParqueMinAggregateInputType
    _max?: EstadoParqueMaxAggregateInputType
  }


  export type EstadoParqueGroupByOutputType = {
    parqueId: number
    estadoId: number
    assignedAt: Date
    assignedBy: string
    _count: EstadoParqueCountAggregateOutputType | null
    _avg: EstadoParqueAvgAggregateOutputType | null
    _sum: EstadoParqueSumAggregateOutputType | null
    _min: EstadoParqueMinAggregateOutputType | null
    _max: EstadoParqueMaxAggregateOutputType | null
  }

  type GetEstadoParqueGroupByPayload<T extends EstadoParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EstadoParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoParqueGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoParqueGroupByOutputType[P]>
        }
      >
    >


  export type EstadoParqueSelect = {
    parque?: boolean | ParqueArgs
    parqueId?: boolean
    estado?: boolean | EstadoArgs
    estadoId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type EstadoParqueInclude = {
    parque?: boolean | ParqueArgs
    estado?: boolean | EstadoArgs
  }

  export type EstadoParqueGetPayload<
    S extends boolean | null | undefined | EstadoParqueArgs,
    U = keyof S
      > = S extends true
        ? EstadoParque
    : S extends undefined
    ? never
    : S extends EstadoParqueArgs | EstadoParqueFindManyArgs
    ?'include' extends U
    ? EstadoParque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :
        P extends 'estado' ? EstadoGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :
        P extends 'estado' ? EstadoGetPayload<S['select'][P]> :  P extends keyof EstadoParque ? EstadoParque[P] : never
  } 
    : EstadoParque
  : EstadoParque


  type EstadoParqueCountArgs = Merge<
    Omit<EstadoParqueFindManyArgs, 'select' | 'include'> & {
      select?: EstadoParqueCountAggregateInputType | true
    }
  >

  export interface EstadoParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EstadoParque that matches the filter.
     * @param {EstadoParqueFindUniqueArgs} args - Arguments to find a EstadoParque
     * @example
     * // Get one EstadoParque
     * const estadoParque = await prisma.estadoParque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstadoParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EstadoParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EstadoParque'> extends True ? CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque>, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T>>> : CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque | null >, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T> | null >>

    /**
     * Find the first EstadoParque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoParqueFindFirstArgs} args - Arguments to find a EstadoParque
     * @example
     * // Get one EstadoParque
     * const estadoParque = await prisma.estadoParque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstadoParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EstadoParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EstadoParque'> extends True ? CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque>, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T>>> : CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque | null >, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T> | null >>

    /**
     * Find zero or more EstadoParques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstadoParques
     * const estadoParques = await prisma.estadoParque.findMany()
     * 
     * // Get first 10 EstadoParques
     * const estadoParques = await prisma.estadoParque.findMany({ take: 10 })
     * 
     * // Only select the `parqueId`
     * const estadoParqueWithParqueIdOnly = await prisma.estadoParque.findMany({ select: { parqueId: true } })
     * 
    **/
    findMany<T extends EstadoParqueFindManyArgs>(
      args?: SelectSubset<T, EstadoParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EstadoParque>>, PrismaPromise<Array<EstadoParqueGetPayload<T>>>>

    /**
     * Create a EstadoParque.
     * @param {EstadoParqueCreateArgs} args - Arguments to create a EstadoParque.
     * @example
     * // Create one EstadoParque
     * const EstadoParque = await prisma.estadoParque.create({
     *   data: {
     *     // ... data to create a EstadoParque
     *   }
     * })
     * 
    **/
    create<T extends EstadoParqueCreateArgs>(
      args: SelectSubset<T, EstadoParqueCreateArgs>
    ): CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque>, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T>>>

    /**
     * Create many EstadoParques.
     *     @param {EstadoParqueCreateManyArgs} args - Arguments to create many EstadoParques.
     *     @example
     *     // Create many EstadoParques
     *     const estadoParque = await prisma.estadoParque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstadoParqueCreateManyArgs>(
      args?: SelectSubset<T, EstadoParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EstadoParque.
     * @param {EstadoParqueDeleteArgs} args - Arguments to delete one EstadoParque.
     * @example
     * // Delete one EstadoParque
     * const EstadoParque = await prisma.estadoParque.delete({
     *   where: {
     *     // ... filter to delete one EstadoParque
     *   }
     * })
     * 
    **/
    delete<T extends EstadoParqueDeleteArgs>(
      args: SelectSubset<T, EstadoParqueDeleteArgs>
    ): CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque>, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T>>>

    /**
     * Update one EstadoParque.
     * @param {EstadoParqueUpdateArgs} args - Arguments to update one EstadoParque.
     * @example
     * // Update one EstadoParque
     * const estadoParque = await prisma.estadoParque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstadoParqueUpdateArgs>(
      args: SelectSubset<T, EstadoParqueUpdateArgs>
    ): CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque>, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T>>>

    /**
     * Delete zero or more EstadoParques.
     * @param {EstadoParqueDeleteManyArgs} args - Arguments to filter EstadoParques to delete.
     * @example
     * // Delete a few EstadoParques
     * const { count } = await prisma.estadoParque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstadoParqueDeleteManyArgs>(
      args?: SelectSubset<T, EstadoParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstadoParques
     * const estadoParque = await prisma.estadoParque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstadoParqueUpdateManyArgs>(
      args: SelectSubset<T, EstadoParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EstadoParque.
     * @param {EstadoParqueUpsertArgs} args - Arguments to update or create a EstadoParque.
     * @example
     * // Update or create a EstadoParque
     * const estadoParque = await prisma.estadoParque.upsert({
     *   create: {
     *     // ... data to create a EstadoParque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstadoParque we want to update
     *   }
     * })
    **/
    upsert<T extends EstadoParqueUpsertArgs>(
      args: SelectSubset<T, EstadoParqueUpsertArgs>
    ): CheckSelect<T, Prisma__EstadoParqueClient<EstadoParque>, Prisma__EstadoParqueClient<EstadoParqueGetPayload<T>>>

    /**
     * Count the number of EstadoParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoParqueCountArgs} args - Arguments to filter EstadoParques to count.
     * @example
     * // Count the number of EstadoParques
     * const count = await prisma.estadoParque.count({
     *   where: {
     *     // ... the filter for the EstadoParques we want to count
     *   }
     * })
    **/
    count<T extends EstadoParqueCountArgs>(
      args?: Subset<T, EstadoParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstadoParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoParqueAggregateArgs>(args: Subset<T, EstadoParqueAggregateArgs>): PrismaPromise<GetEstadoParqueAggregateType<T>>

    /**
     * Group by EstadoParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstadoParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstadoParqueGroupByArgs['orderBy'] }
        : { orderBy?: EstadoParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstadoParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EstadoParque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EstadoParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    estado<T extends EstadoArgs = {}>(args?: Subset<T, EstadoArgs>): CheckSelect<T, Prisma__EstadoClient<Estado | null >, Prisma__EstadoClient<EstadoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EstadoParque findUnique
   */
  export type EstadoParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * Throw an Error if a EstadoParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EstadoParque to fetch.
     * 
    **/
    where: EstadoParqueWhereUniqueInput
  }


  /**
   * EstadoParque findFirst
   */
  export type EstadoParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * Throw an Error if a EstadoParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EstadoParque to fetch.
     * 
    **/
    where?: EstadoParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoParques to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EstadoParques.
     * 
    **/
    cursor?: EstadoParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EstadoParques.
     * 
    **/
    distinct?: Enumerable<EstadoParqueScalarFieldEnum>
  }


  /**
   * EstadoParque findMany
   */
  export type EstadoParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * Filter, which EstadoParques to fetch.
     * 
    **/
    where?: EstadoParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EstadoParques to fetch.
     * 
    **/
    orderBy?: Enumerable<EstadoParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EstadoParques.
     * 
    **/
    cursor?: EstadoParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EstadoParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EstadoParques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EstadoParqueScalarFieldEnum>
  }


  /**
   * EstadoParque create
   */
  export type EstadoParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * The data needed to create a EstadoParque.
     * 
    **/
    data: XOR<EstadoParqueCreateInput, EstadoParqueUncheckedCreateInput>
  }


  /**
   * EstadoParque createMany
   */
  export type EstadoParqueCreateManyArgs = {
    /**
     * The data used to create many EstadoParques.
     * 
    **/
    data: Enumerable<EstadoParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EstadoParque update
   */
  export type EstadoParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * The data needed to update a EstadoParque.
     * 
    **/
    data: XOR<EstadoParqueUpdateInput, EstadoParqueUncheckedUpdateInput>
    /**
     * Choose, which EstadoParque to update.
     * 
    **/
    where: EstadoParqueWhereUniqueInput
  }


  /**
   * EstadoParque updateMany
   */
  export type EstadoParqueUpdateManyArgs = {
    /**
     * The data used to update EstadoParques.
     * 
    **/
    data: XOR<EstadoParqueUpdateManyMutationInput, EstadoParqueUncheckedUpdateManyInput>
    /**
     * Filter which EstadoParques to update
     * 
    **/
    where?: EstadoParqueWhereInput
  }


  /**
   * EstadoParque upsert
   */
  export type EstadoParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * The filter to search for the EstadoParque to update in case it exists.
     * 
    **/
    where: EstadoParqueWhereUniqueInput
    /**
     * In case the EstadoParque found by the `where` argument doesn't exist, create a new EstadoParque with this data.
     * 
    **/
    create: XOR<EstadoParqueCreateInput, EstadoParqueUncheckedCreateInput>
    /**
     * In case the EstadoParque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EstadoParqueUpdateInput, EstadoParqueUncheckedUpdateInput>
  }


  /**
   * EstadoParque delete
   */
  export type EstadoParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
    /**
     * Filter which EstadoParque to delete.
     * 
    **/
    where: EstadoParqueWhereUniqueInput
  }


  /**
   * EstadoParque deleteMany
   */
  export type EstadoParqueDeleteManyArgs = {
    /**
     * Filter which EstadoParques to delete
     * 
    **/
    where?: EstadoParqueWhereInput
  }


  /**
   * EstadoParque without action
   */
  export type EstadoParqueArgs = {
    /**
     * Select specific fields to fetch from the EstadoParque
     * 
    **/
    select?: EstadoParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstadoParqueInclude | null
  }



  /**
   * Model Region
   */


  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type RegionAggregateArgs = {
    /**
     * Filter which Region to aggregate.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs = {
    where?: RegionWhereInput
    orderBy?: Enumerable<RegionOrderByWithAggregationInput>
    by: Array<RegionScalarFieldEnum>
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }


  export type RegionGroupByOutputType = {
    id: number
    nombre: string
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect = {
    id?: boolean
    nombre?: boolean
    parque?: boolean | RegionParqueFindManyArgs
    _count?: boolean | RegionCountOutputTypeArgs
  }

  export type RegionInclude = {
    parque?: boolean | RegionParqueFindManyArgs
    _count?: boolean | RegionCountOutputTypeArgs
  }

  export type RegionGetPayload<
    S extends boolean | null | undefined | RegionArgs,
    U = keyof S
      > = S extends true
        ? Region
    : S extends undefined
    ? never
    : S extends RegionArgs | RegionFindManyArgs
    ?'include' extends U
    ? Region  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? Array < RegionParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? RegionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? Array < RegionParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? RegionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Region ? Region[P] : never
  } 
    : Region
  : Region


  type RegionCountArgs = Merge<
    Omit<RegionFindManyArgs, 'select' | 'include'> & {
      select?: RegionCountAggregateInputType | true
    }
  >

  export interface RegionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null >, Prisma__RegionClient<RegionGetPayload<T> | null >>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null >, Prisma__RegionClient<RegionGetPayload<T> | null >>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs>(
      args?: SelectSubset<T, RegionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Region>>, PrismaPromise<Array<RegionGetPayload<T>>>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs>(
      args: SelectSubset<T, RegionCreateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs>(
      args?: SelectSubset<T, RegionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs>(
      args: SelectSubset<T, RegionDeleteArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs>(
      args: SelectSubset<T, RegionUpdateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs>(
      args?: SelectSubset<T, RegionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs>(
      args: SelectSubset<T, RegionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs>(
      args: SelectSubset<T, RegionUpsertArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends RegionParqueFindManyArgs = {}>(args?: Subset<T, RegionParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RegionParque>>, PrismaPromise<Array<RegionParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Throw an Error if a Region can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Region to fetch.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Throw an Error if a Region can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Region to fetch.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     * 
    **/
    distinct?: Enumerable<RegionScalarFieldEnum>
  }


  /**
   * Region findMany
   */
  export type RegionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Regions to fetch.
     * 
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     * 
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RegionScalarFieldEnum>
  }


  /**
   * Region create
   */
  export type RegionCreateArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The data needed to create a Region.
     * 
    **/
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs = {
    /**
     * The data used to create many Regions.
     * 
    **/
    data: Enumerable<RegionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The data needed to update a Region.
     * 
    **/
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs = {
    /**
     * The data used to update Regions.
     * 
    **/
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     * 
    **/
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * The filter to search for the Region to update in case it exists.
     * 
    **/
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     * 
    **/
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
    /**
     * Filter which Region to delete.
     * 
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs = {
    /**
     * Filter which Regions to delete
     * 
    **/
    where?: RegionWhereInput
  }


  /**
   * Region without action
   */
  export type RegionArgs = {
    /**
     * Select specific fields to fetch from the Region
     * 
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionInclude | null
  }



  /**
   * Model RegionParque
   */


  export type AggregateRegionParque = {
    _count: RegionParqueCountAggregateOutputType | null
    _avg: RegionParqueAvgAggregateOutputType | null
    _sum: RegionParqueSumAggregateOutputType | null
    _min: RegionParqueMinAggregateOutputType | null
    _max: RegionParqueMaxAggregateOutputType | null
  }

  export type RegionParqueAvgAggregateOutputType = {
    parqueId: number | null
    regionId: number | null
  }

  export type RegionParqueSumAggregateOutputType = {
    parqueId: number | null
    regionId: number | null
  }

  export type RegionParqueMinAggregateOutputType = {
    parqueId: number | null
    regionId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type RegionParqueMaxAggregateOutputType = {
    parqueId: number | null
    regionId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type RegionParqueCountAggregateOutputType = {
    parqueId: number
    regionId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type RegionParqueAvgAggregateInputType = {
    parqueId?: true
    regionId?: true
  }

  export type RegionParqueSumAggregateInputType = {
    parqueId?: true
    regionId?: true
  }

  export type RegionParqueMinAggregateInputType = {
    parqueId?: true
    regionId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type RegionParqueMaxAggregateInputType = {
    parqueId?: true
    regionId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type RegionParqueCountAggregateInputType = {
    parqueId?: true
    regionId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type RegionParqueAggregateArgs = {
    /**
     * Filter which RegionParque to aggregate.
     * 
    **/
    where?: RegionParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionParques to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RegionParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionParques
    **/
    _count?: true | RegionParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionParqueMaxAggregateInputType
  }

  export type GetRegionParqueAggregateType<T extends RegionParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionParque[P]>
      : GetScalarType<T[P], AggregateRegionParque[P]>
  }




  export type RegionParqueGroupByArgs = {
    where?: RegionParqueWhereInput
    orderBy?: Enumerable<RegionParqueOrderByWithAggregationInput>
    by: Array<RegionParqueScalarFieldEnum>
    having?: RegionParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionParqueCountAggregateInputType | true
    _avg?: RegionParqueAvgAggregateInputType
    _sum?: RegionParqueSumAggregateInputType
    _min?: RegionParqueMinAggregateInputType
    _max?: RegionParqueMaxAggregateInputType
  }


  export type RegionParqueGroupByOutputType = {
    parqueId: number
    regionId: number
    assignedAt: Date
    assignedBy: string
    _count: RegionParqueCountAggregateOutputType | null
    _avg: RegionParqueAvgAggregateOutputType | null
    _sum: RegionParqueSumAggregateOutputType | null
    _min: RegionParqueMinAggregateOutputType | null
    _max: RegionParqueMaxAggregateOutputType | null
  }

  type GetRegionParqueGroupByPayload<T extends RegionParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RegionParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionParqueGroupByOutputType[P]>
            : GetScalarType<T[P], RegionParqueGroupByOutputType[P]>
        }
      >
    >


  export type RegionParqueSelect = {
    parque?: boolean | ParqueArgs
    parqueId?: boolean
    region?: boolean | RegionArgs
    regionId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type RegionParqueInclude = {
    parque?: boolean | ParqueArgs
    region?: boolean | RegionArgs
  }

  export type RegionParqueGetPayload<
    S extends boolean | null | undefined | RegionParqueArgs,
    U = keyof S
      > = S extends true
        ? RegionParque
    : S extends undefined
    ? never
    : S extends RegionParqueArgs | RegionParqueFindManyArgs
    ?'include' extends U
    ? RegionParque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :
        P extends 'region' ? RegionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :
        P extends 'region' ? RegionGetPayload<S['select'][P]> :  P extends keyof RegionParque ? RegionParque[P] : never
  } 
    : RegionParque
  : RegionParque


  type RegionParqueCountArgs = Merge<
    Omit<RegionParqueFindManyArgs, 'select' | 'include'> & {
      select?: RegionParqueCountAggregateInputType | true
    }
  >

  export interface RegionParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RegionParque that matches the filter.
     * @param {RegionParqueFindUniqueArgs} args - Arguments to find a RegionParque
     * @example
     * // Get one RegionParque
     * const regionParque = await prisma.regionParque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegionParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RegionParque'> extends True ? CheckSelect<T, Prisma__RegionParqueClient<RegionParque>, Prisma__RegionParqueClient<RegionParqueGetPayload<T>>> : CheckSelect<T, Prisma__RegionParqueClient<RegionParque | null >, Prisma__RegionParqueClient<RegionParqueGetPayload<T> | null >>

    /**
     * Find the first RegionParque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionParqueFindFirstArgs} args - Arguments to find a RegionParque
     * @example
     * // Get one RegionParque
     * const regionParque = await prisma.regionParque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegionParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RegionParque'> extends True ? CheckSelect<T, Prisma__RegionParqueClient<RegionParque>, Prisma__RegionParqueClient<RegionParqueGetPayload<T>>> : CheckSelect<T, Prisma__RegionParqueClient<RegionParque | null >, Prisma__RegionParqueClient<RegionParqueGetPayload<T> | null >>

    /**
     * Find zero or more RegionParques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionParques
     * const regionParques = await prisma.regionParque.findMany()
     * 
     * // Get first 10 RegionParques
     * const regionParques = await prisma.regionParque.findMany({ take: 10 })
     * 
     * // Only select the `parqueId`
     * const regionParqueWithParqueIdOnly = await prisma.regionParque.findMany({ select: { parqueId: true } })
     * 
    **/
    findMany<T extends RegionParqueFindManyArgs>(
      args?: SelectSubset<T, RegionParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RegionParque>>, PrismaPromise<Array<RegionParqueGetPayload<T>>>>

    /**
     * Create a RegionParque.
     * @param {RegionParqueCreateArgs} args - Arguments to create a RegionParque.
     * @example
     * // Create one RegionParque
     * const RegionParque = await prisma.regionParque.create({
     *   data: {
     *     // ... data to create a RegionParque
     *   }
     * })
     * 
    **/
    create<T extends RegionParqueCreateArgs>(
      args: SelectSubset<T, RegionParqueCreateArgs>
    ): CheckSelect<T, Prisma__RegionParqueClient<RegionParque>, Prisma__RegionParqueClient<RegionParqueGetPayload<T>>>

    /**
     * Create many RegionParques.
     *     @param {RegionParqueCreateManyArgs} args - Arguments to create many RegionParques.
     *     @example
     *     // Create many RegionParques
     *     const regionParque = await prisma.regionParque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionParqueCreateManyArgs>(
      args?: SelectSubset<T, RegionParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RegionParque.
     * @param {RegionParqueDeleteArgs} args - Arguments to delete one RegionParque.
     * @example
     * // Delete one RegionParque
     * const RegionParque = await prisma.regionParque.delete({
     *   where: {
     *     // ... filter to delete one RegionParque
     *   }
     * })
     * 
    **/
    delete<T extends RegionParqueDeleteArgs>(
      args: SelectSubset<T, RegionParqueDeleteArgs>
    ): CheckSelect<T, Prisma__RegionParqueClient<RegionParque>, Prisma__RegionParqueClient<RegionParqueGetPayload<T>>>

    /**
     * Update one RegionParque.
     * @param {RegionParqueUpdateArgs} args - Arguments to update one RegionParque.
     * @example
     * // Update one RegionParque
     * const regionParque = await prisma.regionParque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionParqueUpdateArgs>(
      args: SelectSubset<T, RegionParqueUpdateArgs>
    ): CheckSelect<T, Prisma__RegionParqueClient<RegionParque>, Prisma__RegionParqueClient<RegionParqueGetPayload<T>>>

    /**
     * Delete zero or more RegionParques.
     * @param {RegionParqueDeleteManyArgs} args - Arguments to filter RegionParques to delete.
     * @example
     * // Delete a few RegionParques
     * const { count } = await prisma.regionParque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionParqueDeleteManyArgs>(
      args?: SelectSubset<T, RegionParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionParques
     * const regionParque = await prisma.regionParque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionParqueUpdateManyArgs>(
      args: SelectSubset<T, RegionParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RegionParque.
     * @param {RegionParqueUpsertArgs} args - Arguments to update or create a RegionParque.
     * @example
     * // Update or create a RegionParque
     * const regionParque = await prisma.regionParque.upsert({
     *   create: {
     *     // ... data to create a RegionParque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionParque we want to update
     *   }
     * })
    **/
    upsert<T extends RegionParqueUpsertArgs>(
      args: SelectSubset<T, RegionParqueUpsertArgs>
    ): CheckSelect<T, Prisma__RegionParqueClient<RegionParque>, Prisma__RegionParqueClient<RegionParqueGetPayload<T>>>

    /**
     * Count the number of RegionParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionParqueCountArgs} args - Arguments to filter RegionParques to count.
     * @example
     * // Count the number of RegionParques
     * const count = await prisma.regionParque.count({
     *   where: {
     *     // ... the filter for the RegionParques we want to count
     *   }
     * })
    **/
    count<T extends RegionParqueCountArgs>(
      args?: Subset<T, RegionParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionParqueAggregateArgs>(args: Subset<T, RegionParqueAggregateArgs>): PrismaPromise<GetRegionParqueAggregateType<T>>

    /**
     * Group by RegionParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionParqueGroupByArgs['orderBy'] }
        : { orderBy?: RegionParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionParque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegionParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    region<T extends RegionArgs = {}>(args?: Subset<T, RegionArgs>): CheckSelect<T, Prisma__RegionClient<Region | null >, Prisma__RegionClient<RegionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RegionParque findUnique
   */
  export type RegionParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * Throw an Error if a RegionParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RegionParque to fetch.
     * 
    **/
    where: RegionParqueWhereUniqueInput
  }


  /**
   * RegionParque findFirst
   */
  export type RegionParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * Throw an Error if a RegionParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RegionParque to fetch.
     * 
    **/
    where?: RegionParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionParques to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionParques.
     * 
    **/
    cursor?: RegionParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionParques.
     * 
    **/
    distinct?: Enumerable<RegionParqueScalarFieldEnum>
  }


  /**
   * RegionParque findMany
   */
  export type RegionParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * Filter, which RegionParques to fetch.
     * 
    **/
    where?: RegionParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionParques to fetch.
     * 
    **/
    orderBy?: Enumerable<RegionParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionParques.
     * 
    **/
    cursor?: RegionParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionParques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RegionParqueScalarFieldEnum>
  }


  /**
   * RegionParque create
   */
  export type RegionParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * The data needed to create a RegionParque.
     * 
    **/
    data: XOR<RegionParqueCreateInput, RegionParqueUncheckedCreateInput>
  }


  /**
   * RegionParque createMany
   */
  export type RegionParqueCreateManyArgs = {
    /**
     * The data used to create many RegionParques.
     * 
    **/
    data: Enumerable<RegionParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RegionParque update
   */
  export type RegionParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * The data needed to update a RegionParque.
     * 
    **/
    data: XOR<RegionParqueUpdateInput, RegionParqueUncheckedUpdateInput>
    /**
     * Choose, which RegionParque to update.
     * 
    **/
    where: RegionParqueWhereUniqueInput
  }


  /**
   * RegionParque updateMany
   */
  export type RegionParqueUpdateManyArgs = {
    /**
     * The data used to update RegionParques.
     * 
    **/
    data: XOR<RegionParqueUpdateManyMutationInput, RegionParqueUncheckedUpdateManyInput>
    /**
     * Filter which RegionParques to update
     * 
    **/
    where?: RegionParqueWhereInput
  }


  /**
   * RegionParque upsert
   */
  export type RegionParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * The filter to search for the RegionParque to update in case it exists.
     * 
    **/
    where: RegionParqueWhereUniqueInput
    /**
     * In case the RegionParque found by the `where` argument doesn't exist, create a new RegionParque with this data.
     * 
    **/
    create: XOR<RegionParqueCreateInput, RegionParqueUncheckedCreateInput>
    /**
     * In case the RegionParque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RegionParqueUpdateInput, RegionParqueUncheckedUpdateInput>
  }


  /**
   * RegionParque delete
   */
  export type RegionParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
    /**
     * Filter which RegionParque to delete.
     * 
    **/
    where: RegionParqueWhereUniqueInput
  }


  /**
   * RegionParque deleteMany
   */
  export type RegionParqueDeleteManyArgs = {
    /**
     * Filter which RegionParques to delete
     * 
    **/
    where?: RegionParqueWhereInput
  }


  /**
   * RegionParque without action
   */
  export type RegionParqueArgs = {
    /**
     * Select specific fields to fetch from the RegionParque
     * 
    **/
    select?: RegionParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RegionParqueInclude | null
  }



  /**
   * Model Categoria
   */


  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type CategoriaAggregateArgs = {
    /**
     * Filter which Categoria to aggregate.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs = {
    where?: CategoriaWhereInput
    orderBy?: Enumerable<CategoriaOrderByWithAggregationInput>
    by: Array<CategoriaScalarFieldEnum>
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }


  export type CategoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect = {
    id?: boolean
    nombre?: boolean
    parque?: boolean | CategoriaParqueFindManyArgs
    _count?: boolean | CategoriaCountOutputTypeArgs
  }

  export type CategoriaInclude = {
    parque?: boolean | CategoriaParqueFindManyArgs
    _count?: boolean | CategoriaCountOutputTypeArgs
  }

  export type CategoriaGetPayload<
    S extends boolean | null | undefined | CategoriaArgs,
    U = keyof S
      > = S extends true
        ? Categoria
    : S extends undefined
    ? never
    : S extends CategoriaArgs | CategoriaFindManyArgs
    ?'include' extends U
    ? Categoria  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? Array < CategoriaParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoriaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? Array < CategoriaParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoriaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Categoria ? Categoria[P] : never
  } 
    : Categoria
  : Categoria


  type CategoriaCountArgs = Merge<
    Omit<CategoriaFindManyArgs, 'select' | 'include'> & {
      select?: CategoriaCountAggregateInputType | true
    }
  >

  export interface CategoriaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categoria'> extends True ? CheckSelect<T, Prisma__CategoriaClient<Categoria>, Prisma__CategoriaClient<CategoriaGetPayload<T>>> : CheckSelect<T, Prisma__CategoriaClient<Categoria | null >, Prisma__CategoriaClient<CategoriaGetPayload<T> | null >>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categoria'> extends True ? CheckSelect<T, Prisma__CategoriaClient<Categoria>, Prisma__CategoriaClient<CategoriaGetPayload<T>>> : CheckSelect<T, Prisma__CategoriaClient<Categoria | null >, Prisma__CategoriaClient<CategoriaGetPayload<T> | null >>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriaFindManyArgs>(
      args?: SelectSubset<T, CategoriaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Categoria>>, PrismaPromise<Array<CategoriaGetPayload<T>>>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
    **/
    create<T extends CategoriaCreateArgs>(
      args: SelectSubset<T, CategoriaCreateArgs>
    ): CheckSelect<T, Prisma__CategoriaClient<Categoria>, Prisma__CategoriaClient<CategoriaGetPayload<T>>>

    /**
     * Create many Categorias.
     *     @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categoria = await prisma.categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaCreateManyArgs>(
      args?: SelectSubset<T, CategoriaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaDeleteArgs>(
      args: SelectSubset<T, CategoriaDeleteArgs>
    ): CheckSelect<T, Prisma__CategoriaClient<Categoria>, Prisma__CategoriaClient<CategoriaGetPayload<T>>>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaUpdateArgs>(
      args: SelectSubset<T, CategoriaUpdateArgs>
    ): CheckSelect<T, Prisma__CategoriaClient<Categoria>, Prisma__CategoriaClient<CategoriaGetPayload<T>>>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaDeleteManyArgs>(
      args?: SelectSubset<T, CategoriaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaUpdateManyArgs>(
      args: SelectSubset<T, CategoriaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaUpsertArgs>(
      args: SelectSubset<T, CategoriaUpsertArgs>
    ): CheckSelect<T, Prisma__CategoriaClient<Categoria>, Prisma__CategoriaClient<CategoriaGetPayload<T>>>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends CategoriaParqueFindManyArgs = {}>(args?: Subset<T, CategoriaParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CategoriaParque>>, PrismaPromise<Array<CategoriaParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Throw an Error if a Categoria can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Categoria to fetch.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Throw an Error if a Categoria can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Categoria to fetch.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     * 
    **/
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter, which Categorias to fetch.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Categoria create
   */
  export type CategoriaCreateArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * The data needed to create a Categoria.
     * 
    **/
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }


  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs = {
    /**
     * The data used to create many Categorias.
     * 
    **/
    data: Enumerable<CategoriaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * The data needed to update a Categoria.
     * 
    **/
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs = {
    /**
     * The data used to update Categorias.
     * 
    **/
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     * 
    **/
    where?: CategoriaWhereInput
  }


  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     * 
    **/
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     * 
    **/
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }


  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter which Categoria to delete.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs = {
    /**
     * Filter which Categorias to delete
     * 
    **/
    where?: CategoriaWhereInput
  }


  /**
   * Categoria without action
   */
  export type CategoriaArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
  }



  /**
   * Model CategoriaParque
   */


  export type AggregateCategoriaParque = {
    _count: CategoriaParqueCountAggregateOutputType | null
    _avg: CategoriaParqueAvgAggregateOutputType | null
    _sum: CategoriaParqueSumAggregateOutputType | null
    _min: CategoriaParqueMinAggregateOutputType | null
    _max: CategoriaParqueMaxAggregateOutputType | null
  }

  export type CategoriaParqueAvgAggregateOutputType = {
    parqueId: number | null
    categoriaId: number | null
  }

  export type CategoriaParqueSumAggregateOutputType = {
    parqueId: number | null
    categoriaId: number | null
  }

  export type CategoriaParqueMinAggregateOutputType = {
    parqueId: number | null
    categoriaId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type CategoriaParqueMaxAggregateOutputType = {
    parqueId: number | null
    categoriaId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type CategoriaParqueCountAggregateOutputType = {
    parqueId: number
    categoriaId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type CategoriaParqueAvgAggregateInputType = {
    parqueId?: true
    categoriaId?: true
  }

  export type CategoriaParqueSumAggregateInputType = {
    parqueId?: true
    categoriaId?: true
  }

  export type CategoriaParqueMinAggregateInputType = {
    parqueId?: true
    categoriaId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type CategoriaParqueMaxAggregateInputType = {
    parqueId?: true
    categoriaId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type CategoriaParqueCountAggregateInputType = {
    parqueId?: true
    categoriaId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type CategoriaParqueAggregateArgs = {
    /**
     * Filter which CategoriaParque to aggregate.
     * 
    **/
    where?: CategoriaParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaParques to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoriaParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoriaParques
    **/
    _count?: true | CategoriaParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaParqueMaxAggregateInputType
  }

  export type GetCategoriaParqueAggregateType<T extends CategoriaParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriaParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriaParque[P]>
      : GetScalarType<T[P], AggregateCategoriaParque[P]>
  }




  export type CategoriaParqueGroupByArgs = {
    where?: CategoriaParqueWhereInput
    orderBy?: Enumerable<CategoriaParqueOrderByWithAggregationInput>
    by: Array<CategoriaParqueScalarFieldEnum>
    having?: CategoriaParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaParqueCountAggregateInputType | true
    _avg?: CategoriaParqueAvgAggregateInputType
    _sum?: CategoriaParqueSumAggregateInputType
    _min?: CategoriaParqueMinAggregateInputType
    _max?: CategoriaParqueMaxAggregateInputType
  }


  export type CategoriaParqueGroupByOutputType = {
    parqueId: number
    categoriaId: number
    assignedAt: Date
    assignedBy: string
    _count: CategoriaParqueCountAggregateOutputType | null
    _avg: CategoriaParqueAvgAggregateOutputType | null
    _sum: CategoriaParqueSumAggregateOutputType | null
    _min: CategoriaParqueMinAggregateOutputType | null
    _max: CategoriaParqueMaxAggregateOutputType | null
  }

  type GetCategoriaParqueGroupByPayload<T extends CategoriaParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoriaParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaParqueGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaParqueGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaParqueSelect = {
    parque?: boolean | ParqueArgs
    parqueId?: boolean
    categoria?: boolean | CategoriaArgs
    categoriaId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type CategoriaParqueInclude = {
    parque?: boolean | ParqueArgs
    categoria?: boolean | CategoriaArgs
  }

  export type CategoriaParqueGetPayload<
    S extends boolean | null | undefined | CategoriaParqueArgs,
    U = keyof S
      > = S extends true
        ? CategoriaParque
    : S extends undefined
    ? never
    : S extends CategoriaParqueArgs | CategoriaParqueFindManyArgs
    ?'include' extends U
    ? CategoriaParque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :
        P extends 'categoria' ? CategoriaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :
        P extends 'categoria' ? CategoriaGetPayload<S['select'][P]> :  P extends keyof CategoriaParque ? CategoriaParque[P] : never
  } 
    : CategoriaParque
  : CategoriaParque


  type CategoriaParqueCountArgs = Merge<
    Omit<CategoriaParqueFindManyArgs, 'select' | 'include'> & {
      select?: CategoriaParqueCountAggregateInputType | true
    }
  >

  export interface CategoriaParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CategoriaParque that matches the filter.
     * @param {CategoriaParqueFindUniqueArgs} args - Arguments to find a CategoriaParque
     * @example
     * // Get one CategoriaParque
     * const categoriaParque = await prisma.categoriaParque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoriaParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CategoriaParque'> extends True ? CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque>, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T>>> : CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque | null >, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T> | null >>

    /**
     * Find the first CategoriaParque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaParqueFindFirstArgs} args - Arguments to find a CategoriaParque
     * @example
     * // Get one CategoriaParque
     * const categoriaParque = await prisma.categoriaParque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoriaParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CategoriaParque'> extends True ? CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque>, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T>>> : CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque | null >, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T> | null >>

    /**
     * Find zero or more CategoriaParques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriaParques
     * const categoriaParques = await prisma.categoriaParque.findMany()
     * 
     * // Get first 10 CategoriaParques
     * const categoriaParques = await prisma.categoriaParque.findMany({ take: 10 })
     * 
     * // Only select the `parqueId`
     * const categoriaParqueWithParqueIdOnly = await prisma.categoriaParque.findMany({ select: { parqueId: true } })
     * 
    **/
    findMany<T extends CategoriaParqueFindManyArgs>(
      args?: SelectSubset<T, CategoriaParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CategoriaParque>>, PrismaPromise<Array<CategoriaParqueGetPayload<T>>>>

    /**
     * Create a CategoriaParque.
     * @param {CategoriaParqueCreateArgs} args - Arguments to create a CategoriaParque.
     * @example
     * // Create one CategoriaParque
     * const CategoriaParque = await prisma.categoriaParque.create({
     *   data: {
     *     // ... data to create a CategoriaParque
     *   }
     * })
     * 
    **/
    create<T extends CategoriaParqueCreateArgs>(
      args: SelectSubset<T, CategoriaParqueCreateArgs>
    ): CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque>, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T>>>

    /**
     * Create many CategoriaParques.
     *     @param {CategoriaParqueCreateManyArgs} args - Arguments to create many CategoriaParques.
     *     @example
     *     // Create many CategoriaParques
     *     const categoriaParque = await prisma.categoriaParque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaParqueCreateManyArgs>(
      args?: SelectSubset<T, CategoriaParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CategoriaParque.
     * @param {CategoriaParqueDeleteArgs} args - Arguments to delete one CategoriaParque.
     * @example
     * // Delete one CategoriaParque
     * const CategoriaParque = await prisma.categoriaParque.delete({
     *   where: {
     *     // ... filter to delete one CategoriaParque
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaParqueDeleteArgs>(
      args: SelectSubset<T, CategoriaParqueDeleteArgs>
    ): CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque>, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T>>>

    /**
     * Update one CategoriaParque.
     * @param {CategoriaParqueUpdateArgs} args - Arguments to update one CategoriaParque.
     * @example
     * // Update one CategoriaParque
     * const categoriaParque = await prisma.categoriaParque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaParqueUpdateArgs>(
      args: SelectSubset<T, CategoriaParqueUpdateArgs>
    ): CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque>, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T>>>

    /**
     * Delete zero or more CategoriaParques.
     * @param {CategoriaParqueDeleteManyArgs} args - Arguments to filter CategoriaParques to delete.
     * @example
     * // Delete a few CategoriaParques
     * const { count } = await prisma.categoriaParque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaParqueDeleteManyArgs>(
      args?: SelectSubset<T, CategoriaParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriaParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriaParques
     * const categoriaParque = await prisma.categoriaParque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaParqueUpdateManyArgs>(
      args: SelectSubset<T, CategoriaParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoriaParque.
     * @param {CategoriaParqueUpsertArgs} args - Arguments to update or create a CategoriaParque.
     * @example
     * // Update or create a CategoriaParque
     * const categoriaParque = await prisma.categoriaParque.upsert({
     *   create: {
     *     // ... data to create a CategoriaParque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriaParque we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaParqueUpsertArgs>(
      args: SelectSubset<T, CategoriaParqueUpsertArgs>
    ): CheckSelect<T, Prisma__CategoriaParqueClient<CategoriaParque>, Prisma__CategoriaParqueClient<CategoriaParqueGetPayload<T>>>

    /**
     * Count the number of CategoriaParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaParqueCountArgs} args - Arguments to filter CategoriaParques to count.
     * @example
     * // Count the number of CategoriaParques
     * const count = await prisma.categoriaParque.count({
     *   where: {
     *     // ... the filter for the CategoriaParques we want to count
     *   }
     * })
    **/
    count<T extends CategoriaParqueCountArgs>(
      args?: Subset<T, CategoriaParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriaParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaParqueAggregateArgs>(args: Subset<T, CategoriaParqueAggregateArgs>): PrismaPromise<GetCategoriaParqueAggregateType<T>>

    /**
     * Group by CategoriaParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaParqueGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoriaParque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriaParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    categoria<T extends CategoriaArgs = {}>(args?: Subset<T, CategoriaArgs>): CheckSelect<T, Prisma__CategoriaClient<Categoria | null >, Prisma__CategoriaClient<CategoriaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CategoriaParque findUnique
   */
  export type CategoriaParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * Throw an Error if a CategoriaParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CategoriaParque to fetch.
     * 
    **/
    where: CategoriaParqueWhereUniqueInput
  }


  /**
   * CategoriaParque findFirst
   */
  export type CategoriaParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * Throw an Error if a CategoriaParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CategoriaParque to fetch.
     * 
    **/
    where?: CategoriaParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaParques to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriaParques.
     * 
    **/
    cursor?: CategoriaParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriaParques.
     * 
    **/
    distinct?: Enumerable<CategoriaParqueScalarFieldEnum>
  }


  /**
   * CategoriaParque findMany
   */
  export type CategoriaParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * Filter, which CategoriaParques to fetch.
     * 
    **/
    where?: CategoriaParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaParques to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoriaParques.
     * 
    **/
    cursor?: CategoriaParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaParques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoriaParqueScalarFieldEnum>
  }


  /**
   * CategoriaParque create
   */
  export type CategoriaParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * The data needed to create a CategoriaParque.
     * 
    **/
    data: XOR<CategoriaParqueCreateInput, CategoriaParqueUncheckedCreateInput>
  }


  /**
   * CategoriaParque createMany
   */
  export type CategoriaParqueCreateManyArgs = {
    /**
     * The data used to create many CategoriaParques.
     * 
    **/
    data: Enumerable<CategoriaParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CategoriaParque update
   */
  export type CategoriaParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * The data needed to update a CategoriaParque.
     * 
    **/
    data: XOR<CategoriaParqueUpdateInput, CategoriaParqueUncheckedUpdateInput>
    /**
     * Choose, which CategoriaParque to update.
     * 
    **/
    where: CategoriaParqueWhereUniqueInput
  }


  /**
   * CategoriaParque updateMany
   */
  export type CategoriaParqueUpdateManyArgs = {
    /**
     * The data used to update CategoriaParques.
     * 
    **/
    data: XOR<CategoriaParqueUpdateManyMutationInput, CategoriaParqueUncheckedUpdateManyInput>
    /**
     * Filter which CategoriaParques to update
     * 
    **/
    where?: CategoriaParqueWhereInput
  }


  /**
   * CategoriaParque upsert
   */
  export type CategoriaParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * The filter to search for the CategoriaParque to update in case it exists.
     * 
    **/
    where: CategoriaParqueWhereUniqueInput
    /**
     * In case the CategoriaParque found by the `where` argument doesn't exist, create a new CategoriaParque with this data.
     * 
    **/
    create: XOR<CategoriaParqueCreateInput, CategoriaParqueUncheckedCreateInput>
    /**
     * In case the CategoriaParque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoriaParqueUpdateInput, CategoriaParqueUncheckedUpdateInput>
  }


  /**
   * CategoriaParque delete
   */
  export type CategoriaParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
    /**
     * Filter which CategoriaParque to delete.
     * 
    **/
    where: CategoriaParqueWhereUniqueInput
  }


  /**
   * CategoriaParque deleteMany
   */
  export type CategoriaParqueDeleteManyArgs = {
    /**
     * Filter which CategoriaParques to delete
     * 
    **/
    where?: CategoriaParqueWhereInput
  }


  /**
   * CategoriaParque without action
   */
  export type CategoriaParqueArgs = {
    /**
     * Select specific fields to fetch from the CategoriaParque
     * 
    **/
    select?: CategoriaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaParqueInclude | null
  }



  /**
   * Model Flora
   */


  export type AggregateFlora = {
    _count: FloraCountAggregateOutputType | null
    _avg: FloraAvgAggregateOutputType | null
    _sum: FloraSumAggregateOutputType | null
    _min: FloraMinAggregateOutputType | null
    _max: FloraMaxAggregateOutputType | null
  }

  export type FloraAvgAggregateOutputType = {
    id: number | null
  }

  export type FloraSumAggregateOutputType = {
    id: number | null
  }

  export type FloraMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    imagen: string | null
    descripcion: string | null
  }

  export type FloraMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    imagen: string | null
    descripcion: string | null
  }

  export type FloraCountAggregateOutputType = {
    id: number
    nombre: number
    imagen: number
    descripcion: number
    _all: number
  }


  export type FloraAvgAggregateInputType = {
    id?: true
  }

  export type FloraSumAggregateInputType = {
    id?: true
  }

  export type FloraMinAggregateInputType = {
    id?: true
    nombre?: true
    imagen?: true
    descripcion?: true
  }

  export type FloraMaxAggregateInputType = {
    id?: true
    nombre?: true
    imagen?: true
    descripcion?: true
  }

  export type FloraCountAggregateInputType = {
    id?: true
    nombre?: true
    imagen?: true
    descripcion?: true
    _all?: true
  }

  export type FloraAggregateArgs = {
    /**
     * Filter which Flora to aggregate.
     * 
    **/
    where?: FloraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floras to fetch.
     * 
    **/
    orderBy?: Enumerable<FloraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FloraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Floras
    **/
    _count?: true | FloraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FloraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FloraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloraMaxAggregateInputType
  }

  export type GetFloraAggregateType<T extends FloraAggregateArgs> = {
        [P in keyof T & keyof AggregateFlora]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlora[P]>
      : GetScalarType<T[P], AggregateFlora[P]>
  }




  export type FloraGroupByArgs = {
    where?: FloraWhereInput
    orderBy?: Enumerable<FloraOrderByWithAggregationInput>
    by: Array<FloraScalarFieldEnum>
    having?: FloraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloraCountAggregateInputType | true
    _avg?: FloraAvgAggregateInputType
    _sum?: FloraSumAggregateInputType
    _min?: FloraMinAggregateInputType
    _max?: FloraMaxAggregateInputType
  }


  export type FloraGroupByOutputType = {
    id: number
    nombre: string
    imagen: string
    descripcion: string
    _count: FloraCountAggregateOutputType | null
    _avg: FloraAvgAggregateOutputType | null
    _sum: FloraSumAggregateOutputType | null
    _min: FloraMinAggregateOutputType | null
    _max: FloraMaxAggregateOutputType | null
  }

  type GetFloraGroupByPayload<T extends FloraGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FloraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloraGroupByOutputType[P]>
            : GetScalarType<T[P], FloraGroupByOutputType[P]>
        }
      >
    >


  export type FloraSelect = {
    id?: boolean
    nombre?: boolean
    imagen?: boolean
    descripcion?: boolean
    parques?: boolean | FloraParqueFindManyArgs
    _count?: boolean | FloraCountOutputTypeArgs
  }

  export type FloraInclude = {
    parques?: boolean | FloraParqueFindManyArgs
    _count?: boolean | FloraCountOutputTypeArgs
  }

  export type FloraGetPayload<
    S extends boolean | null | undefined | FloraArgs,
    U = keyof S
      > = S extends true
        ? Flora
    : S extends undefined
    ? never
    : S extends FloraArgs | FloraFindManyArgs
    ?'include' extends U
    ? Flora  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parques' ? Array < FloraParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? FloraCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parques' ? Array < FloraParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? FloraCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Flora ? Flora[P] : never
  } 
    : Flora
  : Flora


  type FloraCountArgs = Merge<
    Omit<FloraFindManyArgs, 'select' | 'include'> & {
      select?: FloraCountAggregateInputType | true
    }
  >

  export interface FloraDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Flora that matches the filter.
     * @param {FloraFindUniqueArgs} args - Arguments to find a Flora
     * @example
     * // Get one Flora
     * const flora = await prisma.flora.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FloraFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FloraFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Flora'> extends True ? CheckSelect<T, Prisma__FloraClient<Flora>, Prisma__FloraClient<FloraGetPayload<T>>> : CheckSelect<T, Prisma__FloraClient<Flora | null >, Prisma__FloraClient<FloraGetPayload<T> | null >>

    /**
     * Find the first Flora that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraFindFirstArgs} args - Arguments to find a Flora
     * @example
     * // Get one Flora
     * const flora = await prisma.flora.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FloraFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FloraFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Flora'> extends True ? CheckSelect<T, Prisma__FloraClient<Flora>, Prisma__FloraClient<FloraGetPayload<T>>> : CheckSelect<T, Prisma__FloraClient<Flora | null >, Prisma__FloraClient<FloraGetPayload<T> | null >>

    /**
     * Find zero or more Floras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Floras
     * const floras = await prisma.flora.findMany()
     * 
     * // Get first 10 Floras
     * const floras = await prisma.flora.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const floraWithIdOnly = await prisma.flora.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FloraFindManyArgs>(
      args?: SelectSubset<T, FloraFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Flora>>, PrismaPromise<Array<FloraGetPayload<T>>>>

    /**
     * Create a Flora.
     * @param {FloraCreateArgs} args - Arguments to create a Flora.
     * @example
     * // Create one Flora
     * const Flora = await prisma.flora.create({
     *   data: {
     *     // ... data to create a Flora
     *   }
     * })
     * 
    **/
    create<T extends FloraCreateArgs>(
      args: SelectSubset<T, FloraCreateArgs>
    ): CheckSelect<T, Prisma__FloraClient<Flora>, Prisma__FloraClient<FloraGetPayload<T>>>

    /**
     * Create many Floras.
     *     @param {FloraCreateManyArgs} args - Arguments to create many Floras.
     *     @example
     *     // Create many Floras
     *     const flora = await prisma.flora.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FloraCreateManyArgs>(
      args?: SelectSubset<T, FloraCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Flora.
     * @param {FloraDeleteArgs} args - Arguments to delete one Flora.
     * @example
     * // Delete one Flora
     * const Flora = await prisma.flora.delete({
     *   where: {
     *     // ... filter to delete one Flora
     *   }
     * })
     * 
    **/
    delete<T extends FloraDeleteArgs>(
      args: SelectSubset<T, FloraDeleteArgs>
    ): CheckSelect<T, Prisma__FloraClient<Flora>, Prisma__FloraClient<FloraGetPayload<T>>>

    /**
     * Update one Flora.
     * @param {FloraUpdateArgs} args - Arguments to update one Flora.
     * @example
     * // Update one Flora
     * const flora = await prisma.flora.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FloraUpdateArgs>(
      args: SelectSubset<T, FloraUpdateArgs>
    ): CheckSelect<T, Prisma__FloraClient<Flora>, Prisma__FloraClient<FloraGetPayload<T>>>

    /**
     * Delete zero or more Floras.
     * @param {FloraDeleteManyArgs} args - Arguments to filter Floras to delete.
     * @example
     * // Delete a few Floras
     * const { count } = await prisma.flora.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FloraDeleteManyArgs>(
      args?: SelectSubset<T, FloraDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Floras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Floras
     * const flora = await prisma.flora.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FloraUpdateManyArgs>(
      args: SelectSubset<T, FloraUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Flora.
     * @param {FloraUpsertArgs} args - Arguments to update or create a Flora.
     * @example
     * // Update or create a Flora
     * const flora = await prisma.flora.upsert({
     *   create: {
     *     // ... data to create a Flora
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flora we want to update
     *   }
     * })
    **/
    upsert<T extends FloraUpsertArgs>(
      args: SelectSubset<T, FloraUpsertArgs>
    ): CheckSelect<T, Prisma__FloraClient<Flora>, Prisma__FloraClient<FloraGetPayload<T>>>

    /**
     * Count the number of Floras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraCountArgs} args - Arguments to filter Floras to count.
     * @example
     * // Count the number of Floras
     * const count = await prisma.flora.count({
     *   where: {
     *     // ... the filter for the Floras we want to count
     *   }
     * })
    **/
    count<T extends FloraCountArgs>(
      args?: Subset<T, FloraCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloraAggregateArgs>(args: Subset<T, FloraAggregateArgs>): PrismaPromise<GetFloraAggregateType<T>>

    /**
     * Group by Flora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FloraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FloraGroupByArgs['orderBy'] }
        : { orderBy?: FloraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FloraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloraGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flora.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FloraClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parques<T extends FloraParqueFindManyArgs = {}>(args?: Subset<T, FloraParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FloraParque>>, PrismaPromise<Array<FloraParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Flora findUnique
   */
  export type FloraFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * Throw an Error if a Flora can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Flora to fetch.
     * 
    **/
    where: FloraWhereUniqueInput
  }


  /**
   * Flora findFirst
   */
  export type FloraFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * Throw an Error if a Flora can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Flora to fetch.
     * 
    **/
    where?: FloraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floras to fetch.
     * 
    **/
    orderBy?: Enumerable<FloraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Floras.
     * 
    **/
    cursor?: FloraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Floras.
     * 
    **/
    distinct?: Enumerable<FloraScalarFieldEnum>
  }


  /**
   * Flora findMany
   */
  export type FloraFindManyArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * Filter, which Floras to fetch.
     * 
    **/
    where?: FloraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floras to fetch.
     * 
    **/
    orderBy?: Enumerable<FloraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Floras.
     * 
    **/
    cursor?: FloraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FloraScalarFieldEnum>
  }


  /**
   * Flora create
   */
  export type FloraCreateArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * The data needed to create a Flora.
     * 
    **/
    data: XOR<FloraCreateInput, FloraUncheckedCreateInput>
  }


  /**
   * Flora createMany
   */
  export type FloraCreateManyArgs = {
    /**
     * The data used to create many Floras.
     * 
    **/
    data: Enumerable<FloraCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Flora update
   */
  export type FloraUpdateArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * The data needed to update a Flora.
     * 
    **/
    data: XOR<FloraUpdateInput, FloraUncheckedUpdateInput>
    /**
     * Choose, which Flora to update.
     * 
    **/
    where: FloraWhereUniqueInput
  }


  /**
   * Flora updateMany
   */
  export type FloraUpdateManyArgs = {
    /**
     * The data used to update Floras.
     * 
    **/
    data: XOR<FloraUpdateManyMutationInput, FloraUncheckedUpdateManyInput>
    /**
     * Filter which Floras to update
     * 
    **/
    where?: FloraWhereInput
  }


  /**
   * Flora upsert
   */
  export type FloraUpsertArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * The filter to search for the Flora to update in case it exists.
     * 
    **/
    where: FloraWhereUniqueInput
    /**
     * In case the Flora found by the `where` argument doesn't exist, create a new Flora with this data.
     * 
    **/
    create: XOR<FloraCreateInput, FloraUncheckedCreateInput>
    /**
     * In case the Flora was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FloraUpdateInput, FloraUncheckedUpdateInput>
  }


  /**
   * Flora delete
   */
  export type FloraDeleteArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
    /**
     * Filter which Flora to delete.
     * 
    **/
    where: FloraWhereUniqueInput
  }


  /**
   * Flora deleteMany
   */
  export type FloraDeleteManyArgs = {
    /**
     * Filter which Floras to delete
     * 
    **/
    where?: FloraWhereInput
  }


  /**
   * Flora without action
   */
  export type FloraArgs = {
    /**
     * Select specific fields to fetch from the Flora
     * 
    **/
    select?: FloraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraInclude | null
  }



  /**
   * Model FloraParque
   */


  export type AggregateFloraParque = {
    _count: FloraParqueCountAggregateOutputType | null
    _avg: FloraParqueAvgAggregateOutputType | null
    _sum: FloraParqueSumAggregateOutputType | null
    _min: FloraParqueMinAggregateOutputType | null
    _max: FloraParqueMaxAggregateOutputType | null
  }

  export type FloraParqueAvgAggregateOutputType = {
    parqueId: number | null
    floraId: number | null
  }

  export type FloraParqueSumAggregateOutputType = {
    parqueId: number | null
    floraId: number | null
  }

  export type FloraParqueMinAggregateOutputType = {
    parqueId: number | null
    floraId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type FloraParqueMaxAggregateOutputType = {
    parqueId: number | null
    floraId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type FloraParqueCountAggregateOutputType = {
    parqueId: number
    floraId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type FloraParqueAvgAggregateInputType = {
    parqueId?: true
    floraId?: true
  }

  export type FloraParqueSumAggregateInputType = {
    parqueId?: true
    floraId?: true
  }

  export type FloraParqueMinAggregateInputType = {
    parqueId?: true
    floraId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type FloraParqueMaxAggregateInputType = {
    parqueId?: true
    floraId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type FloraParqueCountAggregateInputType = {
    parqueId?: true
    floraId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type FloraParqueAggregateArgs = {
    /**
     * Filter which FloraParque to aggregate.
     * 
    **/
    where?: FloraParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloraParques to fetch.
     * 
    **/
    orderBy?: Enumerable<FloraParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FloraParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloraParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloraParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FloraParques
    **/
    _count?: true | FloraParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FloraParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FloraParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloraParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloraParqueMaxAggregateInputType
  }

  export type GetFloraParqueAggregateType<T extends FloraParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateFloraParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFloraParque[P]>
      : GetScalarType<T[P], AggregateFloraParque[P]>
  }




  export type FloraParqueGroupByArgs = {
    where?: FloraParqueWhereInput
    orderBy?: Enumerable<FloraParqueOrderByWithAggregationInput>
    by: Array<FloraParqueScalarFieldEnum>
    having?: FloraParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloraParqueCountAggregateInputType | true
    _avg?: FloraParqueAvgAggregateInputType
    _sum?: FloraParqueSumAggregateInputType
    _min?: FloraParqueMinAggregateInputType
    _max?: FloraParqueMaxAggregateInputType
  }


  export type FloraParqueGroupByOutputType = {
    parqueId: number
    floraId: number
    assignedAt: Date
    assignedBy: string
    _count: FloraParqueCountAggregateOutputType | null
    _avg: FloraParqueAvgAggregateOutputType | null
    _sum: FloraParqueSumAggregateOutputType | null
    _min: FloraParqueMinAggregateOutputType | null
    _max: FloraParqueMaxAggregateOutputType | null
  }

  type GetFloraParqueGroupByPayload<T extends FloraParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FloraParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloraParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloraParqueGroupByOutputType[P]>
            : GetScalarType<T[P], FloraParqueGroupByOutputType[P]>
        }
      >
    >


  export type FloraParqueSelect = {
    parque?: boolean | ParqueArgs
    parqueId?: boolean
    flora?: boolean | FloraArgs
    floraId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type FloraParqueInclude = {
    parque?: boolean | ParqueArgs
    flora?: boolean | FloraArgs
  }

  export type FloraParqueGetPayload<
    S extends boolean | null | undefined | FloraParqueArgs,
    U = keyof S
      > = S extends true
        ? FloraParque
    : S extends undefined
    ? never
    : S extends FloraParqueArgs | FloraParqueFindManyArgs
    ?'include' extends U
    ? FloraParque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :
        P extends 'flora' ? FloraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :
        P extends 'flora' ? FloraGetPayload<S['select'][P]> :  P extends keyof FloraParque ? FloraParque[P] : never
  } 
    : FloraParque
  : FloraParque


  type FloraParqueCountArgs = Merge<
    Omit<FloraParqueFindManyArgs, 'select' | 'include'> & {
      select?: FloraParqueCountAggregateInputType | true
    }
  >

  export interface FloraParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FloraParque that matches the filter.
     * @param {FloraParqueFindUniqueArgs} args - Arguments to find a FloraParque
     * @example
     * // Get one FloraParque
     * const floraParque = await prisma.floraParque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FloraParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FloraParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FloraParque'> extends True ? CheckSelect<T, Prisma__FloraParqueClient<FloraParque>, Prisma__FloraParqueClient<FloraParqueGetPayload<T>>> : CheckSelect<T, Prisma__FloraParqueClient<FloraParque | null >, Prisma__FloraParqueClient<FloraParqueGetPayload<T> | null >>

    /**
     * Find the first FloraParque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraParqueFindFirstArgs} args - Arguments to find a FloraParque
     * @example
     * // Get one FloraParque
     * const floraParque = await prisma.floraParque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FloraParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FloraParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FloraParque'> extends True ? CheckSelect<T, Prisma__FloraParqueClient<FloraParque>, Prisma__FloraParqueClient<FloraParqueGetPayload<T>>> : CheckSelect<T, Prisma__FloraParqueClient<FloraParque | null >, Prisma__FloraParqueClient<FloraParqueGetPayload<T> | null >>

    /**
     * Find zero or more FloraParques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FloraParques
     * const floraParques = await prisma.floraParque.findMany()
     * 
     * // Get first 10 FloraParques
     * const floraParques = await prisma.floraParque.findMany({ take: 10 })
     * 
     * // Only select the `parqueId`
     * const floraParqueWithParqueIdOnly = await prisma.floraParque.findMany({ select: { parqueId: true } })
     * 
    **/
    findMany<T extends FloraParqueFindManyArgs>(
      args?: SelectSubset<T, FloraParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FloraParque>>, PrismaPromise<Array<FloraParqueGetPayload<T>>>>

    /**
     * Create a FloraParque.
     * @param {FloraParqueCreateArgs} args - Arguments to create a FloraParque.
     * @example
     * // Create one FloraParque
     * const FloraParque = await prisma.floraParque.create({
     *   data: {
     *     // ... data to create a FloraParque
     *   }
     * })
     * 
    **/
    create<T extends FloraParqueCreateArgs>(
      args: SelectSubset<T, FloraParqueCreateArgs>
    ): CheckSelect<T, Prisma__FloraParqueClient<FloraParque>, Prisma__FloraParqueClient<FloraParqueGetPayload<T>>>

    /**
     * Create many FloraParques.
     *     @param {FloraParqueCreateManyArgs} args - Arguments to create many FloraParques.
     *     @example
     *     // Create many FloraParques
     *     const floraParque = await prisma.floraParque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FloraParqueCreateManyArgs>(
      args?: SelectSubset<T, FloraParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FloraParque.
     * @param {FloraParqueDeleteArgs} args - Arguments to delete one FloraParque.
     * @example
     * // Delete one FloraParque
     * const FloraParque = await prisma.floraParque.delete({
     *   where: {
     *     // ... filter to delete one FloraParque
     *   }
     * })
     * 
    **/
    delete<T extends FloraParqueDeleteArgs>(
      args: SelectSubset<T, FloraParqueDeleteArgs>
    ): CheckSelect<T, Prisma__FloraParqueClient<FloraParque>, Prisma__FloraParqueClient<FloraParqueGetPayload<T>>>

    /**
     * Update one FloraParque.
     * @param {FloraParqueUpdateArgs} args - Arguments to update one FloraParque.
     * @example
     * // Update one FloraParque
     * const floraParque = await prisma.floraParque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FloraParqueUpdateArgs>(
      args: SelectSubset<T, FloraParqueUpdateArgs>
    ): CheckSelect<T, Prisma__FloraParqueClient<FloraParque>, Prisma__FloraParqueClient<FloraParqueGetPayload<T>>>

    /**
     * Delete zero or more FloraParques.
     * @param {FloraParqueDeleteManyArgs} args - Arguments to filter FloraParques to delete.
     * @example
     * // Delete a few FloraParques
     * const { count } = await prisma.floraParque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FloraParqueDeleteManyArgs>(
      args?: SelectSubset<T, FloraParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FloraParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FloraParques
     * const floraParque = await prisma.floraParque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FloraParqueUpdateManyArgs>(
      args: SelectSubset<T, FloraParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FloraParque.
     * @param {FloraParqueUpsertArgs} args - Arguments to update or create a FloraParque.
     * @example
     * // Update or create a FloraParque
     * const floraParque = await prisma.floraParque.upsert({
     *   create: {
     *     // ... data to create a FloraParque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FloraParque we want to update
     *   }
     * })
    **/
    upsert<T extends FloraParqueUpsertArgs>(
      args: SelectSubset<T, FloraParqueUpsertArgs>
    ): CheckSelect<T, Prisma__FloraParqueClient<FloraParque>, Prisma__FloraParqueClient<FloraParqueGetPayload<T>>>

    /**
     * Count the number of FloraParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraParqueCountArgs} args - Arguments to filter FloraParques to count.
     * @example
     * // Count the number of FloraParques
     * const count = await prisma.floraParque.count({
     *   where: {
     *     // ... the filter for the FloraParques we want to count
     *   }
     * })
    **/
    count<T extends FloraParqueCountArgs>(
      args?: Subset<T, FloraParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloraParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FloraParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloraParqueAggregateArgs>(args: Subset<T, FloraParqueAggregateArgs>): PrismaPromise<GetFloraParqueAggregateType<T>>

    /**
     * Group by FloraParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloraParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FloraParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FloraParqueGroupByArgs['orderBy'] }
        : { orderBy?: FloraParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FloraParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloraParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FloraParque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FloraParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    flora<T extends FloraArgs = {}>(args?: Subset<T, FloraArgs>): CheckSelect<T, Prisma__FloraClient<Flora | null >, Prisma__FloraClient<FloraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FloraParque findUnique
   */
  export type FloraParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * Throw an Error if a FloraParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FloraParque to fetch.
     * 
    **/
    where: FloraParqueWhereUniqueInput
  }


  /**
   * FloraParque findFirst
   */
  export type FloraParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * Throw an Error if a FloraParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FloraParque to fetch.
     * 
    **/
    where?: FloraParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloraParques to fetch.
     * 
    **/
    orderBy?: Enumerable<FloraParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloraParques.
     * 
    **/
    cursor?: FloraParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloraParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloraParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloraParques.
     * 
    **/
    distinct?: Enumerable<FloraParqueScalarFieldEnum>
  }


  /**
   * FloraParque findMany
   */
  export type FloraParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * Filter, which FloraParques to fetch.
     * 
    **/
    where?: FloraParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloraParques to fetch.
     * 
    **/
    orderBy?: Enumerable<FloraParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FloraParques.
     * 
    **/
    cursor?: FloraParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloraParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloraParques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FloraParqueScalarFieldEnum>
  }


  /**
   * FloraParque create
   */
  export type FloraParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * The data needed to create a FloraParque.
     * 
    **/
    data: XOR<FloraParqueCreateInput, FloraParqueUncheckedCreateInput>
  }


  /**
   * FloraParque createMany
   */
  export type FloraParqueCreateManyArgs = {
    /**
     * The data used to create many FloraParques.
     * 
    **/
    data: Enumerable<FloraParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FloraParque update
   */
  export type FloraParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * The data needed to update a FloraParque.
     * 
    **/
    data: XOR<FloraParqueUpdateInput, FloraParqueUncheckedUpdateInput>
    /**
     * Choose, which FloraParque to update.
     * 
    **/
    where: FloraParqueWhereUniqueInput
  }


  /**
   * FloraParque updateMany
   */
  export type FloraParqueUpdateManyArgs = {
    /**
     * The data used to update FloraParques.
     * 
    **/
    data: XOR<FloraParqueUpdateManyMutationInput, FloraParqueUncheckedUpdateManyInput>
    /**
     * Filter which FloraParques to update
     * 
    **/
    where?: FloraParqueWhereInput
  }


  /**
   * FloraParque upsert
   */
  export type FloraParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * The filter to search for the FloraParque to update in case it exists.
     * 
    **/
    where: FloraParqueWhereUniqueInput
    /**
     * In case the FloraParque found by the `where` argument doesn't exist, create a new FloraParque with this data.
     * 
    **/
    create: XOR<FloraParqueCreateInput, FloraParqueUncheckedCreateInput>
    /**
     * In case the FloraParque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FloraParqueUpdateInput, FloraParqueUncheckedUpdateInput>
  }


  /**
   * FloraParque delete
   */
  export type FloraParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
    /**
     * Filter which FloraParque to delete.
     * 
    **/
    where: FloraParqueWhereUniqueInput
  }


  /**
   * FloraParque deleteMany
   */
  export type FloraParqueDeleteManyArgs = {
    /**
     * Filter which FloraParques to delete
     * 
    **/
    where?: FloraParqueWhereInput
  }


  /**
   * FloraParque without action
   */
  export type FloraParqueArgs = {
    /**
     * Select specific fields to fetch from the FloraParque
     * 
    **/
    select?: FloraParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FloraParqueInclude | null
  }



  /**
   * Model Fauna
   */


  export type AggregateFauna = {
    _count: FaunaCountAggregateOutputType | null
    _avg: FaunaAvgAggregateOutputType | null
    _sum: FaunaSumAggregateOutputType | null
    _min: FaunaMinAggregateOutputType | null
    _max: FaunaMaxAggregateOutputType | null
  }

  export type FaunaAvgAggregateOutputType = {
    id: number | null
  }

  export type FaunaSumAggregateOutputType = {
    id: number | null
  }

  export type FaunaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    imagen: string | null
    descripcion: string | null
  }

  export type FaunaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    imagen: string | null
    descripcion: string | null
  }

  export type FaunaCountAggregateOutputType = {
    id: number
    nombre: number
    imagen: number
    descripcion: number
    _all: number
  }


  export type FaunaAvgAggregateInputType = {
    id?: true
  }

  export type FaunaSumAggregateInputType = {
    id?: true
  }

  export type FaunaMinAggregateInputType = {
    id?: true
    nombre?: true
    imagen?: true
    descripcion?: true
  }

  export type FaunaMaxAggregateInputType = {
    id?: true
    nombre?: true
    imagen?: true
    descripcion?: true
  }

  export type FaunaCountAggregateInputType = {
    id?: true
    nombre?: true
    imagen?: true
    descripcion?: true
    _all?: true
  }

  export type FaunaAggregateArgs = {
    /**
     * Filter which Fauna to aggregate.
     * 
    **/
    where?: FaunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faunas to fetch.
     * 
    **/
    orderBy?: Enumerable<FaunaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FaunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faunas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faunas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faunas
    **/
    _count?: true | FaunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaunaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaunaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaunaMaxAggregateInputType
  }

  export type GetFaunaAggregateType<T extends FaunaAggregateArgs> = {
        [P in keyof T & keyof AggregateFauna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFauna[P]>
      : GetScalarType<T[P], AggregateFauna[P]>
  }




  export type FaunaGroupByArgs = {
    where?: FaunaWhereInput
    orderBy?: Enumerable<FaunaOrderByWithAggregationInput>
    by: Array<FaunaScalarFieldEnum>
    having?: FaunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaunaCountAggregateInputType | true
    _avg?: FaunaAvgAggregateInputType
    _sum?: FaunaSumAggregateInputType
    _min?: FaunaMinAggregateInputType
    _max?: FaunaMaxAggregateInputType
  }


  export type FaunaGroupByOutputType = {
    id: number
    nombre: string
    imagen: string
    descripcion: string
    _count: FaunaCountAggregateOutputType | null
    _avg: FaunaAvgAggregateOutputType | null
    _sum: FaunaSumAggregateOutputType | null
    _min: FaunaMinAggregateOutputType | null
    _max: FaunaMaxAggregateOutputType | null
  }

  type GetFaunaGroupByPayload<T extends FaunaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FaunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaunaGroupByOutputType[P]>
            : GetScalarType<T[P], FaunaGroupByOutputType[P]>
        }
      >
    >


  export type FaunaSelect = {
    id?: boolean
    nombre?: boolean
    imagen?: boolean
    descripcion?: boolean
    parques?: boolean | FaunaParqueFindManyArgs
    _count?: boolean | FaunaCountOutputTypeArgs
  }

  export type FaunaInclude = {
    parques?: boolean | FaunaParqueFindManyArgs
    _count?: boolean | FaunaCountOutputTypeArgs
  }

  export type FaunaGetPayload<
    S extends boolean | null | undefined | FaunaArgs,
    U = keyof S
      > = S extends true
        ? Fauna
    : S extends undefined
    ? never
    : S extends FaunaArgs | FaunaFindManyArgs
    ?'include' extends U
    ? Fauna  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parques' ? Array < FaunaParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? FaunaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parques' ? Array < FaunaParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? FaunaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Fauna ? Fauna[P] : never
  } 
    : Fauna
  : Fauna


  type FaunaCountArgs = Merge<
    Omit<FaunaFindManyArgs, 'select' | 'include'> & {
      select?: FaunaCountAggregateInputType | true
    }
  >

  export interface FaunaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Fauna that matches the filter.
     * @param {FaunaFindUniqueArgs} args - Arguments to find a Fauna
     * @example
     * // Get one Fauna
     * const fauna = await prisma.fauna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FaunaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FaunaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fauna'> extends True ? CheckSelect<T, Prisma__FaunaClient<Fauna>, Prisma__FaunaClient<FaunaGetPayload<T>>> : CheckSelect<T, Prisma__FaunaClient<Fauna | null >, Prisma__FaunaClient<FaunaGetPayload<T> | null >>

    /**
     * Find the first Fauna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaFindFirstArgs} args - Arguments to find a Fauna
     * @example
     * // Get one Fauna
     * const fauna = await prisma.fauna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FaunaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FaunaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fauna'> extends True ? CheckSelect<T, Prisma__FaunaClient<Fauna>, Prisma__FaunaClient<FaunaGetPayload<T>>> : CheckSelect<T, Prisma__FaunaClient<Fauna | null >, Prisma__FaunaClient<FaunaGetPayload<T> | null >>

    /**
     * Find zero or more Faunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faunas
     * const faunas = await prisma.fauna.findMany()
     * 
     * // Get first 10 Faunas
     * const faunas = await prisma.fauna.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faunaWithIdOnly = await prisma.fauna.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FaunaFindManyArgs>(
      args?: SelectSubset<T, FaunaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Fauna>>, PrismaPromise<Array<FaunaGetPayload<T>>>>

    /**
     * Create a Fauna.
     * @param {FaunaCreateArgs} args - Arguments to create a Fauna.
     * @example
     * // Create one Fauna
     * const Fauna = await prisma.fauna.create({
     *   data: {
     *     // ... data to create a Fauna
     *   }
     * })
     * 
    **/
    create<T extends FaunaCreateArgs>(
      args: SelectSubset<T, FaunaCreateArgs>
    ): CheckSelect<T, Prisma__FaunaClient<Fauna>, Prisma__FaunaClient<FaunaGetPayload<T>>>

    /**
     * Create many Faunas.
     *     @param {FaunaCreateManyArgs} args - Arguments to create many Faunas.
     *     @example
     *     // Create many Faunas
     *     const fauna = await prisma.fauna.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FaunaCreateManyArgs>(
      args?: SelectSubset<T, FaunaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fauna.
     * @param {FaunaDeleteArgs} args - Arguments to delete one Fauna.
     * @example
     * // Delete one Fauna
     * const Fauna = await prisma.fauna.delete({
     *   where: {
     *     // ... filter to delete one Fauna
     *   }
     * })
     * 
    **/
    delete<T extends FaunaDeleteArgs>(
      args: SelectSubset<T, FaunaDeleteArgs>
    ): CheckSelect<T, Prisma__FaunaClient<Fauna>, Prisma__FaunaClient<FaunaGetPayload<T>>>

    /**
     * Update one Fauna.
     * @param {FaunaUpdateArgs} args - Arguments to update one Fauna.
     * @example
     * // Update one Fauna
     * const fauna = await prisma.fauna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FaunaUpdateArgs>(
      args: SelectSubset<T, FaunaUpdateArgs>
    ): CheckSelect<T, Prisma__FaunaClient<Fauna>, Prisma__FaunaClient<FaunaGetPayload<T>>>

    /**
     * Delete zero or more Faunas.
     * @param {FaunaDeleteManyArgs} args - Arguments to filter Faunas to delete.
     * @example
     * // Delete a few Faunas
     * const { count } = await prisma.fauna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FaunaDeleteManyArgs>(
      args?: SelectSubset<T, FaunaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faunas
     * const fauna = await prisma.fauna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FaunaUpdateManyArgs>(
      args: SelectSubset<T, FaunaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fauna.
     * @param {FaunaUpsertArgs} args - Arguments to update or create a Fauna.
     * @example
     * // Update or create a Fauna
     * const fauna = await prisma.fauna.upsert({
     *   create: {
     *     // ... data to create a Fauna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fauna we want to update
     *   }
     * })
    **/
    upsert<T extends FaunaUpsertArgs>(
      args: SelectSubset<T, FaunaUpsertArgs>
    ): CheckSelect<T, Prisma__FaunaClient<Fauna>, Prisma__FaunaClient<FaunaGetPayload<T>>>

    /**
     * Count the number of Faunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaCountArgs} args - Arguments to filter Faunas to count.
     * @example
     * // Count the number of Faunas
     * const count = await prisma.fauna.count({
     *   where: {
     *     // ... the filter for the Faunas we want to count
     *   }
     * })
    **/
    count<T extends FaunaCountArgs>(
      args?: Subset<T, FaunaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fauna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaunaAggregateArgs>(args: Subset<T, FaunaAggregateArgs>): PrismaPromise<GetFaunaAggregateType<T>>

    /**
     * Group by Fauna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaunaGroupByArgs['orderBy'] }
        : { orderBy?: FaunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaunaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fauna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FaunaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parques<T extends FaunaParqueFindManyArgs = {}>(args?: Subset<T, FaunaParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FaunaParque>>, PrismaPromise<Array<FaunaParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Fauna findUnique
   */
  export type FaunaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * Throw an Error if a Fauna can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fauna to fetch.
     * 
    **/
    where: FaunaWhereUniqueInput
  }


  /**
   * Fauna findFirst
   */
  export type FaunaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * Throw an Error if a Fauna can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fauna to fetch.
     * 
    **/
    where?: FaunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faunas to fetch.
     * 
    **/
    orderBy?: Enumerable<FaunaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faunas.
     * 
    **/
    cursor?: FaunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faunas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faunas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faunas.
     * 
    **/
    distinct?: Enumerable<FaunaScalarFieldEnum>
  }


  /**
   * Fauna findMany
   */
  export type FaunaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * Filter, which Faunas to fetch.
     * 
    **/
    where?: FaunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faunas to fetch.
     * 
    **/
    orderBy?: Enumerable<FaunaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faunas.
     * 
    **/
    cursor?: FaunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faunas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faunas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FaunaScalarFieldEnum>
  }


  /**
   * Fauna create
   */
  export type FaunaCreateArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * The data needed to create a Fauna.
     * 
    **/
    data: XOR<FaunaCreateInput, FaunaUncheckedCreateInput>
  }


  /**
   * Fauna createMany
   */
  export type FaunaCreateManyArgs = {
    /**
     * The data used to create many Faunas.
     * 
    **/
    data: Enumerable<FaunaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Fauna update
   */
  export type FaunaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * The data needed to update a Fauna.
     * 
    **/
    data: XOR<FaunaUpdateInput, FaunaUncheckedUpdateInput>
    /**
     * Choose, which Fauna to update.
     * 
    **/
    where: FaunaWhereUniqueInput
  }


  /**
   * Fauna updateMany
   */
  export type FaunaUpdateManyArgs = {
    /**
     * The data used to update Faunas.
     * 
    **/
    data: XOR<FaunaUpdateManyMutationInput, FaunaUncheckedUpdateManyInput>
    /**
     * Filter which Faunas to update
     * 
    **/
    where?: FaunaWhereInput
  }


  /**
   * Fauna upsert
   */
  export type FaunaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * The filter to search for the Fauna to update in case it exists.
     * 
    **/
    where: FaunaWhereUniqueInput
    /**
     * In case the Fauna found by the `where` argument doesn't exist, create a new Fauna with this data.
     * 
    **/
    create: XOR<FaunaCreateInput, FaunaUncheckedCreateInput>
    /**
     * In case the Fauna was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FaunaUpdateInput, FaunaUncheckedUpdateInput>
  }


  /**
   * Fauna delete
   */
  export type FaunaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
    /**
     * Filter which Fauna to delete.
     * 
    **/
    where: FaunaWhereUniqueInput
  }


  /**
   * Fauna deleteMany
   */
  export type FaunaDeleteManyArgs = {
    /**
     * Filter which Faunas to delete
     * 
    **/
    where?: FaunaWhereInput
  }


  /**
   * Fauna without action
   */
  export type FaunaArgs = {
    /**
     * Select specific fields to fetch from the Fauna
     * 
    **/
    select?: FaunaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaInclude | null
  }



  /**
   * Model FaunaParque
   */


  export type AggregateFaunaParque = {
    _count: FaunaParqueCountAggregateOutputType | null
    _avg: FaunaParqueAvgAggregateOutputType | null
    _sum: FaunaParqueSumAggregateOutputType | null
    _min: FaunaParqueMinAggregateOutputType | null
    _max: FaunaParqueMaxAggregateOutputType | null
  }

  export type FaunaParqueAvgAggregateOutputType = {
    parqueId: number | null
    faunaID: number | null
  }

  export type FaunaParqueSumAggregateOutputType = {
    parqueId: number | null
    faunaID: number | null
  }

  export type FaunaParqueMinAggregateOutputType = {
    parqueId: number | null
    faunaID: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type FaunaParqueMaxAggregateOutputType = {
    parqueId: number | null
    faunaID: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type FaunaParqueCountAggregateOutputType = {
    parqueId: number
    faunaID: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type FaunaParqueAvgAggregateInputType = {
    parqueId?: true
    faunaID?: true
  }

  export type FaunaParqueSumAggregateInputType = {
    parqueId?: true
    faunaID?: true
  }

  export type FaunaParqueMinAggregateInputType = {
    parqueId?: true
    faunaID?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type FaunaParqueMaxAggregateInputType = {
    parqueId?: true
    faunaID?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type FaunaParqueCountAggregateInputType = {
    parqueId?: true
    faunaID?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type FaunaParqueAggregateArgs = {
    /**
     * Filter which FaunaParque to aggregate.
     * 
    **/
    where?: FaunaParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaunaParques to fetch.
     * 
    **/
    orderBy?: Enumerable<FaunaParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FaunaParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaunaParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaunaParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FaunaParques
    **/
    _count?: true | FaunaParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaunaParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaunaParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaunaParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaunaParqueMaxAggregateInputType
  }

  export type GetFaunaParqueAggregateType<T extends FaunaParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateFaunaParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaunaParque[P]>
      : GetScalarType<T[P], AggregateFaunaParque[P]>
  }




  export type FaunaParqueGroupByArgs = {
    where?: FaunaParqueWhereInput
    orderBy?: Enumerable<FaunaParqueOrderByWithAggregationInput>
    by: Array<FaunaParqueScalarFieldEnum>
    having?: FaunaParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaunaParqueCountAggregateInputType | true
    _avg?: FaunaParqueAvgAggregateInputType
    _sum?: FaunaParqueSumAggregateInputType
    _min?: FaunaParqueMinAggregateInputType
    _max?: FaunaParqueMaxAggregateInputType
  }


  export type FaunaParqueGroupByOutputType = {
    parqueId: number
    faunaID: number
    assignedAt: Date
    assignedBy: string
    _count: FaunaParqueCountAggregateOutputType | null
    _avg: FaunaParqueAvgAggregateOutputType | null
    _sum: FaunaParqueSumAggregateOutputType | null
    _min: FaunaParqueMinAggregateOutputType | null
    _max: FaunaParqueMaxAggregateOutputType | null
  }

  type GetFaunaParqueGroupByPayload<T extends FaunaParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FaunaParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaunaParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaunaParqueGroupByOutputType[P]>
            : GetScalarType<T[P], FaunaParqueGroupByOutputType[P]>
        }
      >
    >


  export type FaunaParqueSelect = {
    parque?: boolean | ParqueArgs
    parqueId?: boolean
    fauna?: boolean | FaunaArgs
    faunaID?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type FaunaParqueInclude = {
    parque?: boolean | ParqueArgs
    fauna?: boolean | FaunaArgs
  }

  export type FaunaParqueGetPayload<
    S extends boolean | null | undefined | FaunaParqueArgs,
    U = keyof S
      > = S extends true
        ? FaunaParque
    : S extends undefined
    ? never
    : S extends FaunaParqueArgs | FaunaParqueFindManyArgs
    ?'include' extends U
    ? FaunaParque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :
        P extends 'fauna' ? FaunaGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :
        P extends 'fauna' ? FaunaGetPayload<S['select'][P]> :  P extends keyof FaunaParque ? FaunaParque[P] : never
  } 
    : FaunaParque
  : FaunaParque


  type FaunaParqueCountArgs = Merge<
    Omit<FaunaParqueFindManyArgs, 'select' | 'include'> & {
      select?: FaunaParqueCountAggregateInputType | true
    }
  >

  export interface FaunaParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FaunaParque that matches the filter.
     * @param {FaunaParqueFindUniqueArgs} args - Arguments to find a FaunaParque
     * @example
     * // Get one FaunaParque
     * const faunaParque = await prisma.faunaParque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FaunaParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FaunaParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FaunaParque'> extends True ? CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque>, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T>>> : CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque | null >, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T> | null >>

    /**
     * Find the first FaunaParque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaParqueFindFirstArgs} args - Arguments to find a FaunaParque
     * @example
     * // Get one FaunaParque
     * const faunaParque = await prisma.faunaParque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FaunaParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FaunaParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FaunaParque'> extends True ? CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque>, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T>>> : CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque | null >, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T> | null >>

    /**
     * Find zero or more FaunaParques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FaunaParques
     * const faunaParques = await prisma.faunaParque.findMany()
     * 
     * // Get first 10 FaunaParques
     * const faunaParques = await prisma.faunaParque.findMany({ take: 10 })
     * 
     * // Only select the `parqueId`
     * const faunaParqueWithParqueIdOnly = await prisma.faunaParque.findMany({ select: { parqueId: true } })
     * 
    **/
    findMany<T extends FaunaParqueFindManyArgs>(
      args?: SelectSubset<T, FaunaParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FaunaParque>>, PrismaPromise<Array<FaunaParqueGetPayload<T>>>>

    /**
     * Create a FaunaParque.
     * @param {FaunaParqueCreateArgs} args - Arguments to create a FaunaParque.
     * @example
     * // Create one FaunaParque
     * const FaunaParque = await prisma.faunaParque.create({
     *   data: {
     *     // ... data to create a FaunaParque
     *   }
     * })
     * 
    **/
    create<T extends FaunaParqueCreateArgs>(
      args: SelectSubset<T, FaunaParqueCreateArgs>
    ): CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque>, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T>>>

    /**
     * Create many FaunaParques.
     *     @param {FaunaParqueCreateManyArgs} args - Arguments to create many FaunaParques.
     *     @example
     *     // Create many FaunaParques
     *     const faunaParque = await prisma.faunaParque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FaunaParqueCreateManyArgs>(
      args?: SelectSubset<T, FaunaParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FaunaParque.
     * @param {FaunaParqueDeleteArgs} args - Arguments to delete one FaunaParque.
     * @example
     * // Delete one FaunaParque
     * const FaunaParque = await prisma.faunaParque.delete({
     *   where: {
     *     // ... filter to delete one FaunaParque
     *   }
     * })
     * 
    **/
    delete<T extends FaunaParqueDeleteArgs>(
      args: SelectSubset<T, FaunaParqueDeleteArgs>
    ): CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque>, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T>>>

    /**
     * Update one FaunaParque.
     * @param {FaunaParqueUpdateArgs} args - Arguments to update one FaunaParque.
     * @example
     * // Update one FaunaParque
     * const faunaParque = await prisma.faunaParque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FaunaParqueUpdateArgs>(
      args: SelectSubset<T, FaunaParqueUpdateArgs>
    ): CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque>, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T>>>

    /**
     * Delete zero or more FaunaParques.
     * @param {FaunaParqueDeleteManyArgs} args - Arguments to filter FaunaParques to delete.
     * @example
     * // Delete a few FaunaParques
     * const { count } = await prisma.faunaParque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FaunaParqueDeleteManyArgs>(
      args?: SelectSubset<T, FaunaParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FaunaParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FaunaParques
     * const faunaParque = await prisma.faunaParque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FaunaParqueUpdateManyArgs>(
      args: SelectSubset<T, FaunaParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FaunaParque.
     * @param {FaunaParqueUpsertArgs} args - Arguments to update or create a FaunaParque.
     * @example
     * // Update or create a FaunaParque
     * const faunaParque = await prisma.faunaParque.upsert({
     *   create: {
     *     // ... data to create a FaunaParque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FaunaParque we want to update
     *   }
     * })
    **/
    upsert<T extends FaunaParqueUpsertArgs>(
      args: SelectSubset<T, FaunaParqueUpsertArgs>
    ): CheckSelect<T, Prisma__FaunaParqueClient<FaunaParque>, Prisma__FaunaParqueClient<FaunaParqueGetPayload<T>>>

    /**
     * Count the number of FaunaParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaParqueCountArgs} args - Arguments to filter FaunaParques to count.
     * @example
     * // Count the number of FaunaParques
     * const count = await prisma.faunaParque.count({
     *   where: {
     *     // ... the filter for the FaunaParques we want to count
     *   }
     * })
    **/
    count<T extends FaunaParqueCountArgs>(
      args?: Subset<T, FaunaParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaunaParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FaunaParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaunaParqueAggregateArgs>(args: Subset<T, FaunaParqueAggregateArgs>): PrismaPromise<GetFaunaParqueAggregateType<T>>

    /**
     * Group by FaunaParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaunaParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaunaParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaunaParqueGroupByArgs['orderBy'] }
        : { orderBy?: FaunaParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaunaParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaunaParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FaunaParque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FaunaParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    fauna<T extends FaunaArgs = {}>(args?: Subset<T, FaunaArgs>): CheckSelect<T, Prisma__FaunaClient<Fauna | null >, Prisma__FaunaClient<FaunaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FaunaParque findUnique
   */
  export type FaunaParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * Throw an Error if a FaunaParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FaunaParque to fetch.
     * 
    **/
    where: FaunaParqueWhereUniqueInput
  }


  /**
   * FaunaParque findFirst
   */
  export type FaunaParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * Throw an Error if a FaunaParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FaunaParque to fetch.
     * 
    **/
    where?: FaunaParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaunaParques to fetch.
     * 
    **/
    orderBy?: Enumerable<FaunaParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FaunaParques.
     * 
    **/
    cursor?: FaunaParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaunaParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaunaParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FaunaParques.
     * 
    **/
    distinct?: Enumerable<FaunaParqueScalarFieldEnum>
  }


  /**
   * FaunaParque findMany
   */
  export type FaunaParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * Filter, which FaunaParques to fetch.
     * 
    **/
    where?: FaunaParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FaunaParques to fetch.
     * 
    **/
    orderBy?: Enumerable<FaunaParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FaunaParques.
     * 
    **/
    cursor?: FaunaParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FaunaParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FaunaParques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FaunaParqueScalarFieldEnum>
  }


  /**
   * FaunaParque create
   */
  export type FaunaParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * The data needed to create a FaunaParque.
     * 
    **/
    data: XOR<FaunaParqueCreateInput, FaunaParqueUncheckedCreateInput>
  }


  /**
   * FaunaParque createMany
   */
  export type FaunaParqueCreateManyArgs = {
    /**
     * The data used to create many FaunaParques.
     * 
    **/
    data: Enumerable<FaunaParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FaunaParque update
   */
  export type FaunaParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * The data needed to update a FaunaParque.
     * 
    **/
    data: XOR<FaunaParqueUpdateInput, FaunaParqueUncheckedUpdateInput>
    /**
     * Choose, which FaunaParque to update.
     * 
    **/
    where: FaunaParqueWhereUniqueInput
  }


  /**
   * FaunaParque updateMany
   */
  export type FaunaParqueUpdateManyArgs = {
    /**
     * The data used to update FaunaParques.
     * 
    **/
    data: XOR<FaunaParqueUpdateManyMutationInput, FaunaParqueUncheckedUpdateManyInput>
    /**
     * Filter which FaunaParques to update
     * 
    **/
    where?: FaunaParqueWhereInput
  }


  /**
   * FaunaParque upsert
   */
  export type FaunaParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * The filter to search for the FaunaParque to update in case it exists.
     * 
    **/
    where: FaunaParqueWhereUniqueInput
    /**
     * In case the FaunaParque found by the `where` argument doesn't exist, create a new FaunaParque with this data.
     * 
    **/
    create: XOR<FaunaParqueCreateInput, FaunaParqueUncheckedCreateInput>
    /**
     * In case the FaunaParque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FaunaParqueUpdateInput, FaunaParqueUncheckedUpdateInput>
  }


  /**
   * FaunaParque delete
   */
  export type FaunaParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
    /**
     * Filter which FaunaParque to delete.
     * 
    **/
    where: FaunaParqueWhereUniqueInput
  }


  /**
   * FaunaParque deleteMany
   */
  export type FaunaParqueDeleteManyArgs = {
    /**
     * Filter which FaunaParques to delete
     * 
    **/
    where?: FaunaParqueWhereInput
  }


  /**
   * FaunaParque without action
   */
  export type FaunaParqueArgs = {
    /**
     * Select specific fields to fetch from the FaunaParque
     * 
    **/
    select?: FaunaParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FaunaParqueInclude | null
  }



  /**
   * Model Actividad
   */


  export type AggregateActividad = {
    _count: ActividadCountAggregateOutputType | null
    _avg: ActividadAvgAggregateOutputType | null
    _sum: ActividadSumAggregateOutputType | null
    _min: ActividadMinAggregateOutputType | null
    _max: ActividadMaxAggregateOutputType | null
  }

  export type ActividadAvgAggregateOutputType = {
    id: number | null
  }

  export type ActividadSumAggregateOutputType = {
    id: number | null
  }

  export type ActividadMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type ActividadMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type ActividadCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type ActividadAvgAggregateInputType = {
    id?: true
  }

  export type ActividadSumAggregateInputType = {
    id?: true
  }

  export type ActividadMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type ActividadMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type ActividadCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type ActividadAggregateArgs = {
    /**
     * Filter which Actividad to aggregate.
     * 
    **/
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     * 
    **/
    orderBy?: Enumerable<ActividadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actividads
    **/
    _count?: true | ActividadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActividadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActividadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadMaxAggregateInputType
  }

  export type GetActividadAggregateType<T extends ActividadAggregateArgs> = {
        [P in keyof T & keyof AggregateActividad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividad[P]>
      : GetScalarType<T[P], AggregateActividad[P]>
  }




  export type ActividadGroupByArgs = {
    where?: ActividadWhereInput
    orderBy?: Enumerable<ActividadOrderByWithAggregationInput>
    by: Array<ActividadScalarFieldEnum>
    having?: ActividadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadCountAggregateInputType | true
    _avg?: ActividadAvgAggregateInputType
    _sum?: ActividadSumAggregateInputType
    _min?: ActividadMinAggregateInputType
    _max?: ActividadMaxAggregateInputType
  }


  export type ActividadGroupByOutputType = {
    id: number
    nombre: string
    _count: ActividadCountAggregateOutputType | null
    _avg: ActividadAvgAggregateOutputType | null
    _sum: ActividadSumAggregateOutputType | null
    _min: ActividadMinAggregateOutputType | null
    _max: ActividadMaxAggregateOutputType | null
  }

  type GetActividadGroupByPayload<T extends ActividadGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActividadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadGroupByOutputType[P]>
        }
      >
    >


  export type ActividadSelect = {
    id?: boolean
    nombre?: boolean
    parques?: boolean | ActividadParqueFindManyArgs
    _count?: boolean | ActividadCountOutputTypeArgs
  }

  export type ActividadInclude = {
    parques?: boolean | ActividadParqueFindManyArgs
    _count?: boolean | ActividadCountOutputTypeArgs
  }

  export type ActividadGetPayload<
    S extends boolean | null | undefined | ActividadArgs,
    U = keyof S
      > = S extends true
        ? Actividad
    : S extends undefined
    ? never
    : S extends ActividadArgs | ActividadFindManyArgs
    ?'include' extends U
    ? Actividad  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parques' ? Array < ActividadParqueGetPayload<S['include'][P]>>  :
        P extends '_count' ? ActividadCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parques' ? Array < ActividadParqueGetPayload<S['select'][P]>>  :
        P extends '_count' ? ActividadCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Actividad ? Actividad[P] : never
  } 
    : Actividad
  : Actividad


  type ActividadCountArgs = Merge<
    Omit<ActividadFindManyArgs, 'select' | 'include'> & {
      select?: ActividadCountAggregateInputType | true
    }
  >

  export interface ActividadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Actividad that matches the filter.
     * @param {ActividadFindUniqueArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActividadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActividadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Actividad'> extends True ? CheckSelect<T, Prisma__ActividadClient<Actividad>, Prisma__ActividadClient<ActividadGetPayload<T>>> : CheckSelect<T, Prisma__ActividadClient<Actividad | null >, Prisma__ActividadClient<ActividadGetPayload<T> | null >>

    /**
     * Find the first Actividad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindFirstArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActividadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActividadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Actividad'> extends True ? CheckSelect<T, Prisma__ActividadClient<Actividad>, Prisma__ActividadClient<ActividadGetPayload<T>>> : CheckSelect<T, Prisma__ActividadClient<Actividad | null >, Prisma__ActividadClient<ActividadGetPayload<T> | null >>

    /**
     * Find zero or more Actividads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actividads
     * const actividads = await prisma.actividad.findMany()
     * 
     * // Get first 10 Actividads
     * const actividads = await prisma.actividad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actividadWithIdOnly = await prisma.actividad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActividadFindManyArgs>(
      args?: SelectSubset<T, ActividadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Actividad>>, PrismaPromise<Array<ActividadGetPayload<T>>>>

    /**
     * Create a Actividad.
     * @param {ActividadCreateArgs} args - Arguments to create a Actividad.
     * @example
     * // Create one Actividad
     * const Actividad = await prisma.actividad.create({
     *   data: {
     *     // ... data to create a Actividad
     *   }
     * })
     * 
    **/
    create<T extends ActividadCreateArgs>(
      args: SelectSubset<T, ActividadCreateArgs>
    ): CheckSelect<T, Prisma__ActividadClient<Actividad>, Prisma__ActividadClient<ActividadGetPayload<T>>>

    /**
     * Create many Actividads.
     *     @param {ActividadCreateManyArgs} args - Arguments to create many Actividads.
     *     @example
     *     // Create many Actividads
     *     const actividad = await prisma.actividad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActividadCreateManyArgs>(
      args?: SelectSubset<T, ActividadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Actividad.
     * @param {ActividadDeleteArgs} args - Arguments to delete one Actividad.
     * @example
     * // Delete one Actividad
     * const Actividad = await prisma.actividad.delete({
     *   where: {
     *     // ... filter to delete one Actividad
     *   }
     * })
     * 
    **/
    delete<T extends ActividadDeleteArgs>(
      args: SelectSubset<T, ActividadDeleteArgs>
    ): CheckSelect<T, Prisma__ActividadClient<Actividad>, Prisma__ActividadClient<ActividadGetPayload<T>>>

    /**
     * Update one Actividad.
     * @param {ActividadUpdateArgs} args - Arguments to update one Actividad.
     * @example
     * // Update one Actividad
     * const actividad = await prisma.actividad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActividadUpdateArgs>(
      args: SelectSubset<T, ActividadUpdateArgs>
    ): CheckSelect<T, Prisma__ActividadClient<Actividad>, Prisma__ActividadClient<ActividadGetPayload<T>>>

    /**
     * Delete zero or more Actividads.
     * @param {ActividadDeleteManyArgs} args - Arguments to filter Actividads to delete.
     * @example
     * // Delete a few Actividads
     * const { count } = await prisma.actividad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActividadDeleteManyArgs>(
      args?: SelectSubset<T, ActividadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actividads
     * const actividad = await prisma.actividad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActividadUpdateManyArgs>(
      args: SelectSubset<T, ActividadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Actividad.
     * @param {ActividadUpsertArgs} args - Arguments to update or create a Actividad.
     * @example
     * // Update or create a Actividad
     * const actividad = await prisma.actividad.upsert({
     *   create: {
     *     // ... data to create a Actividad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actividad we want to update
     *   }
     * })
    **/
    upsert<T extends ActividadUpsertArgs>(
      args: SelectSubset<T, ActividadUpsertArgs>
    ): CheckSelect<T, Prisma__ActividadClient<Actividad>, Prisma__ActividadClient<ActividadGetPayload<T>>>

    /**
     * Count the number of Actividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadCountArgs} args - Arguments to filter Actividads to count.
     * @example
     * // Count the number of Actividads
     * const count = await prisma.actividad.count({
     *   where: {
     *     // ... the filter for the Actividads we want to count
     *   }
     * })
    **/
    count<T extends ActividadCountArgs>(
      args?: Subset<T, ActividadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadAggregateArgs>(args: Subset<T, ActividadAggregateArgs>): PrismaPromise<GetActividadAggregateType<T>>

    /**
     * Group by Actividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActividadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActividadGroupByArgs['orderBy'] }
        : { orderBy?: ActividadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActividadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Actividad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActividadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parques<T extends ActividadParqueFindManyArgs = {}>(args?: Subset<T, ActividadParqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ActividadParque>>, PrismaPromise<Array<ActividadParqueGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Actividad findUnique
   */
  export type ActividadFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * Throw an Error if a Actividad can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Actividad to fetch.
     * 
    **/
    where: ActividadWhereUniqueInput
  }


  /**
   * Actividad findFirst
   */
  export type ActividadFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * Throw an Error if a Actividad can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Actividad to fetch.
     * 
    **/
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     * 
    **/
    orderBy?: Enumerable<ActividadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actividads.
     * 
    **/
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actividads.
     * 
    **/
    distinct?: Enumerable<ActividadScalarFieldEnum>
  }


  /**
   * Actividad findMany
   */
  export type ActividadFindManyArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * Filter, which Actividads to fetch.
     * 
    **/
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     * 
    **/
    orderBy?: Enumerable<ActividadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actividads.
     * 
    **/
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActividadScalarFieldEnum>
  }


  /**
   * Actividad create
   */
  export type ActividadCreateArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * The data needed to create a Actividad.
     * 
    **/
    data: XOR<ActividadCreateInput, ActividadUncheckedCreateInput>
  }


  /**
   * Actividad createMany
   */
  export type ActividadCreateManyArgs = {
    /**
     * The data used to create many Actividads.
     * 
    **/
    data: Enumerable<ActividadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Actividad update
   */
  export type ActividadUpdateArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * The data needed to update a Actividad.
     * 
    **/
    data: XOR<ActividadUpdateInput, ActividadUncheckedUpdateInput>
    /**
     * Choose, which Actividad to update.
     * 
    **/
    where: ActividadWhereUniqueInput
  }


  /**
   * Actividad updateMany
   */
  export type ActividadUpdateManyArgs = {
    /**
     * The data used to update Actividads.
     * 
    **/
    data: XOR<ActividadUpdateManyMutationInput, ActividadUncheckedUpdateManyInput>
    /**
     * Filter which Actividads to update
     * 
    **/
    where?: ActividadWhereInput
  }


  /**
   * Actividad upsert
   */
  export type ActividadUpsertArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * The filter to search for the Actividad to update in case it exists.
     * 
    **/
    where: ActividadWhereUniqueInput
    /**
     * In case the Actividad found by the `where` argument doesn't exist, create a new Actividad with this data.
     * 
    **/
    create: XOR<ActividadCreateInput, ActividadUncheckedCreateInput>
    /**
     * In case the Actividad was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActividadUpdateInput, ActividadUncheckedUpdateInput>
  }


  /**
   * Actividad delete
   */
  export type ActividadDeleteArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
    /**
     * Filter which Actividad to delete.
     * 
    **/
    where: ActividadWhereUniqueInput
  }


  /**
   * Actividad deleteMany
   */
  export type ActividadDeleteManyArgs = {
    /**
     * Filter which Actividads to delete
     * 
    **/
    where?: ActividadWhereInput
  }


  /**
   * Actividad without action
   */
  export type ActividadArgs = {
    /**
     * Select specific fields to fetch from the Actividad
     * 
    **/
    select?: ActividadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadInclude | null
  }



  /**
   * Model ActividadParque
   */


  export type AggregateActividadParque = {
    _count: ActividadParqueCountAggregateOutputType | null
    _avg: ActividadParqueAvgAggregateOutputType | null
    _sum: ActividadParqueSumAggregateOutputType | null
    _min: ActividadParqueMinAggregateOutputType | null
    _max: ActividadParqueMaxAggregateOutputType | null
  }

  export type ActividadParqueAvgAggregateOutputType = {
    parqueId: number | null
    actividadId: number | null
  }

  export type ActividadParqueSumAggregateOutputType = {
    parqueId: number | null
    actividadId: number | null
  }

  export type ActividadParqueMinAggregateOutputType = {
    parqueId: number | null
    actividadId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type ActividadParqueMaxAggregateOutputType = {
    parqueId: number | null
    actividadId: number | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type ActividadParqueCountAggregateOutputType = {
    parqueId: number
    actividadId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type ActividadParqueAvgAggregateInputType = {
    parqueId?: true
    actividadId?: true
  }

  export type ActividadParqueSumAggregateInputType = {
    parqueId?: true
    actividadId?: true
  }

  export type ActividadParqueMinAggregateInputType = {
    parqueId?: true
    actividadId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type ActividadParqueMaxAggregateInputType = {
    parqueId?: true
    actividadId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type ActividadParqueCountAggregateInputType = {
    parqueId?: true
    actividadId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type ActividadParqueAggregateArgs = {
    /**
     * Filter which ActividadParque to aggregate.
     * 
    **/
    where?: ActividadParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadParques to fetch.
     * 
    **/
    orderBy?: Enumerable<ActividadParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActividadParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActividadParques
    **/
    _count?: true | ActividadParqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActividadParqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActividadParqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadParqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadParqueMaxAggregateInputType
  }

  export type GetActividadParqueAggregateType<T extends ActividadParqueAggregateArgs> = {
        [P in keyof T & keyof AggregateActividadParque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividadParque[P]>
      : GetScalarType<T[P], AggregateActividadParque[P]>
  }




  export type ActividadParqueGroupByArgs = {
    where?: ActividadParqueWhereInput
    orderBy?: Enumerable<ActividadParqueOrderByWithAggregationInput>
    by: Array<ActividadParqueScalarFieldEnum>
    having?: ActividadParqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadParqueCountAggregateInputType | true
    _avg?: ActividadParqueAvgAggregateInputType
    _sum?: ActividadParqueSumAggregateInputType
    _min?: ActividadParqueMinAggregateInputType
    _max?: ActividadParqueMaxAggregateInputType
  }


  export type ActividadParqueGroupByOutputType = {
    parqueId: number
    actividadId: number
    assignedAt: Date
    assignedBy: string
    _count: ActividadParqueCountAggregateOutputType | null
    _avg: ActividadParqueAvgAggregateOutputType | null
    _sum: ActividadParqueSumAggregateOutputType | null
    _min: ActividadParqueMinAggregateOutputType | null
    _max: ActividadParqueMaxAggregateOutputType | null
  }

  type GetActividadParqueGroupByPayload<T extends ActividadParqueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActividadParqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadParqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadParqueGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadParqueGroupByOutputType[P]>
        }
      >
    >


  export type ActividadParqueSelect = {
    parque?: boolean | ParqueArgs
    parqueId?: boolean
    actividad?: boolean | ActividadArgs
    actividadId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type ActividadParqueInclude = {
    parque?: boolean | ParqueArgs
    actividad?: boolean | ActividadArgs
  }

  export type ActividadParqueGetPayload<
    S extends boolean | null | undefined | ActividadParqueArgs,
    U = keyof S
      > = S extends true
        ? ActividadParque
    : S extends undefined
    ? never
    : S extends ActividadParqueArgs | ActividadParqueFindManyArgs
    ?'include' extends U
    ? ActividadParque  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :
        P extends 'actividad' ? ActividadGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :
        P extends 'actividad' ? ActividadGetPayload<S['select'][P]> :  P extends keyof ActividadParque ? ActividadParque[P] : never
  } 
    : ActividadParque
  : ActividadParque


  type ActividadParqueCountArgs = Merge<
    Omit<ActividadParqueFindManyArgs, 'select' | 'include'> & {
      select?: ActividadParqueCountAggregateInputType | true
    }
  >

  export interface ActividadParqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ActividadParque that matches the filter.
     * @param {ActividadParqueFindUniqueArgs} args - Arguments to find a ActividadParque
     * @example
     * // Get one ActividadParque
     * const actividadParque = await prisma.actividadParque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActividadParqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActividadParqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ActividadParque'> extends True ? CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque>, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T>>> : CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque | null >, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T> | null >>

    /**
     * Find the first ActividadParque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadParqueFindFirstArgs} args - Arguments to find a ActividadParque
     * @example
     * // Get one ActividadParque
     * const actividadParque = await prisma.actividadParque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActividadParqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActividadParqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ActividadParque'> extends True ? CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque>, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T>>> : CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque | null >, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T> | null >>

    /**
     * Find zero or more ActividadParques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadParqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActividadParques
     * const actividadParques = await prisma.actividadParque.findMany()
     * 
     * // Get first 10 ActividadParques
     * const actividadParques = await prisma.actividadParque.findMany({ take: 10 })
     * 
     * // Only select the `parqueId`
     * const actividadParqueWithParqueIdOnly = await prisma.actividadParque.findMany({ select: { parqueId: true } })
     * 
    **/
    findMany<T extends ActividadParqueFindManyArgs>(
      args?: SelectSubset<T, ActividadParqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ActividadParque>>, PrismaPromise<Array<ActividadParqueGetPayload<T>>>>

    /**
     * Create a ActividadParque.
     * @param {ActividadParqueCreateArgs} args - Arguments to create a ActividadParque.
     * @example
     * // Create one ActividadParque
     * const ActividadParque = await prisma.actividadParque.create({
     *   data: {
     *     // ... data to create a ActividadParque
     *   }
     * })
     * 
    **/
    create<T extends ActividadParqueCreateArgs>(
      args: SelectSubset<T, ActividadParqueCreateArgs>
    ): CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque>, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T>>>

    /**
     * Create many ActividadParques.
     *     @param {ActividadParqueCreateManyArgs} args - Arguments to create many ActividadParques.
     *     @example
     *     // Create many ActividadParques
     *     const actividadParque = await prisma.actividadParque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActividadParqueCreateManyArgs>(
      args?: SelectSubset<T, ActividadParqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ActividadParque.
     * @param {ActividadParqueDeleteArgs} args - Arguments to delete one ActividadParque.
     * @example
     * // Delete one ActividadParque
     * const ActividadParque = await prisma.actividadParque.delete({
     *   where: {
     *     // ... filter to delete one ActividadParque
     *   }
     * })
     * 
    **/
    delete<T extends ActividadParqueDeleteArgs>(
      args: SelectSubset<T, ActividadParqueDeleteArgs>
    ): CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque>, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T>>>

    /**
     * Update one ActividadParque.
     * @param {ActividadParqueUpdateArgs} args - Arguments to update one ActividadParque.
     * @example
     * // Update one ActividadParque
     * const actividadParque = await prisma.actividadParque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActividadParqueUpdateArgs>(
      args: SelectSubset<T, ActividadParqueUpdateArgs>
    ): CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque>, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T>>>

    /**
     * Delete zero or more ActividadParques.
     * @param {ActividadParqueDeleteManyArgs} args - Arguments to filter ActividadParques to delete.
     * @example
     * // Delete a few ActividadParques
     * const { count } = await prisma.actividadParque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActividadParqueDeleteManyArgs>(
      args?: SelectSubset<T, ActividadParqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActividadParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadParqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActividadParques
     * const actividadParque = await prisma.actividadParque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActividadParqueUpdateManyArgs>(
      args: SelectSubset<T, ActividadParqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ActividadParque.
     * @param {ActividadParqueUpsertArgs} args - Arguments to update or create a ActividadParque.
     * @example
     * // Update or create a ActividadParque
     * const actividadParque = await prisma.actividadParque.upsert({
     *   create: {
     *     // ... data to create a ActividadParque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActividadParque we want to update
     *   }
     * })
    **/
    upsert<T extends ActividadParqueUpsertArgs>(
      args: SelectSubset<T, ActividadParqueUpsertArgs>
    ): CheckSelect<T, Prisma__ActividadParqueClient<ActividadParque>, Prisma__ActividadParqueClient<ActividadParqueGetPayload<T>>>

    /**
     * Count the number of ActividadParques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadParqueCountArgs} args - Arguments to filter ActividadParques to count.
     * @example
     * // Count the number of ActividadParques
     * const count = await prisma.actividadParque.count({
     *   where: {
     *     // ... the filter for the ActividadParques we want to count
     *   }
     * })
    **/
    count<T extends ActividadParqueCountArgs>(
      args?: Subset<T, ActividadParqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadParqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActividadParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadParqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadParqueAggregateArgs>(args: Subset<T, ActividadParqueAggregateArgs>): PrismaPromise<GetActividadParqueAggregateType<T>>

    /**
     * Group by ActividadParque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadParqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActividadParqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActividadParqueGroupByArgs['orderBy'] }
        : { orderBy?: ActividadParqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActividadParqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadParqueGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActividadParque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActividadParqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    actividad<T extends ActividadArgs = {}>(args?: Subset<T, ActividadArgs>): CheckSelect<T, Prisma__ActividadClient<Actividad | null >, Prisma__ActividadClient<ActividadGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ActividadParque findUnique
   */
  export type ActividadParqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * Throw an Error if a ActividadParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ActividadParque to fetch.
     * 
    **/
    where: ActividadParqueWhereUniqueInput
  }


  /**
   * ActividadParque findFirst
   */
  export type ActividadParqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * Throw an Error if a ActividadParque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ActividadParque to fetch.
     * 
    **/
    where?: ActividadParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadParques to fetch.
     * 
    **/
    orderBy?: Enumerable<ActividadParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActividadParques.
     * 
    **/
    cursor?: ActividadParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadParques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActividadParques.
     * 
    **/
    distinct?: Enumerable<ActividadParqueScalarFieldEnum>
  }


  /**
   * ActividadParque findMany
   */
  export type ActividadParqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * Filter, which ActividadParques to fetch.
     * 
    **/
    where?: ActividadParqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActividadParques to fetch.
     * 
    **/
    orderBy?: Enumerable<ActividadParqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActividadParques.
     * 
    **/
    cursor?: ActividadParqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActividadParques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActividadParques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActividadParqueScalarFieldEnum>
  }


  /**
   * ActividadParque create
   */
  export type ActividadParqueCreateArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * The data needed to create a ActividadParque.
     * 
    **/
    data: XOR<ActividadParqueCreateInput, ActividadParqueUncheckedCreateInput>
  }


  /**
   * ActividadParque createMany
   */
  export type ActividadParqueCreateManyArgs = {
    /**
     * The data used to create many ActividadParques.
     * 
    **/
    data: Enumerable<ActividadParqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ActividadParque update
   */
  export type ActividadParqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * The data needed to update a ActividadParque.
     * 
    **/
    data: XOR<ActividadParqueUpdateInput, ActividadParqueUncheckedUpdateInput>
    /**
     * Choose, which ActividadParque to update.
     * 
    **/
    where: ActividadParqueWhereUniqueInput
  }


  /**
   * ActividadParque updateMany
   */
  export type ActividadParqueUpdateManyArgs = {
    /**
     * The data used to update ActividadParques.
     * 
    **/
    data: XOR<ActividadParqueUpdateManyMutationInput, ActividadParqueUncheckedUpdateManyInput>
    /**
     * Filter which ActividadParques to update
     * 
    **/
    where?: ActividadParqueWhereInput
  }


  /**
   * ActividadParque upsert
   */
  export type ActividadParqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * The filter to search for the ActividadParque to update in case it exists.
     * 
    **/
    where: ActividadParqueWhereUniqueInput
    /**
     * In case the ActividadParque found by the `where` argument doesn't exist, create a new ActividadParque with this data.
     * 
    **/
    create: XOR<ActividadParqueCreateInput, ActividadParqueUncheckedCreateInput>
    /**
     * In case the ActividadParque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActividadParqueUpdateInput, ActividadParqueUncheckedUpdateInput>
  }


  /**
   * ActividadParque delete
   */
  export type ActividadParqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
    /**
     * Filter which ActividadParque to delete.
     * 
    **/
    where: ActividadParqueWhereUniqueInput
  }


  /**
   * ActividadParque deleteMany
   */
  export type ActividadParqueDeleteManyArgs = {
    /**
     * Filter which ActividadParques to delete
     * 
    **/
    where?: ActividadParqueWhereInput
  }


  /**
   * ActividadParque without action
   */
  export type ActividadParqueArgs = {
    /**
     * Select specific fields to fetch from the ActividadParque
     * 
    **/
    select?: ActividadParqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActividadParqueInclude | null
  }



  /**
   * Model Anuncio
   */


  export type AggregateAnuncio = {
    _count: AnuncioCountAggregateOutputType | null
    _avg: AnuncioAvgAggregateOutputType | null
    _sum: AnuncioSumAggregateOutputType | null
    _min: AnuncioMinAggregateOutputType | null
    _max: AnuncioMaxAggregateOutputType | null
  }

  export type AnuncioAvgAggregateOutputType = {
    id: number | null
    parqueId: number | null
  }

  export type AnuncioSumAggregateOutputType = {
    id: number | null
    parqueId: number | null
  }

  export type AnuncioMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    variante: string | null
    parqueId: number | null
  }

  export type AnuncioMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    variante: string | null
    parqueId: number | null
  }

  export type AnuncioCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    variante: number
    parqueId: number
    _all: number
  }


  export type AnuncioAvgAggregateInputType = {
    id?: true
    parqueId?: true
  }

  export type AnuncioSumAggregateInputType = {
    id?: true
    parqueId?: true
  }

  export type AnuncioMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    variante?: true
    parqueId?: true
  }

  export type AnuncioMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    variante?: true
    parqueId?: true
  }

  export type AnuncioCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    variante?: true
    parqueId?: true
    _all?: true
  }

  export type AnuncioAggregateArgs = {
    /**
     * Filter which Anuncio to aggregate.
     * 
    **/
    where?: AnuncioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anuncios to fetch.
     * 
    **/
    orderBy?: Enumerable<AnuncioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AnuncioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anuncios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anuncios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anuncios
    **/
    _count?: true | AnuncioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnuncioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnuncioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnuncioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnuncioMaxAggregateInputType
  }

  export type GetAnuncioAggregateType<T extends AnuncioAggregateArgs> = {
        [P in keyof T & keyof AggregateAnuncio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnuncio[P]>
      : GetScalarType<T[P], AggregateAnuncio[P]>
  }




  export type AnuncioGroupByArgs = {
    where?: AnuncioWhereInput
    orderBy?: Enumerable<AnuncioOrderByWithAggregationInput>
    by: Array<AnuncioScalarFieldEnum>
    having?: AnuncioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnuncioCountAggregateInputType | true
    _avg?: AnuncioAvgAggregateInputType
    _sum?: AnuncioSumAggregateInputType
    _min?: AnuncioMinAggregateInputType
    _max?: AnuncioMaxAggregateInputType
  }


  export type AnuncioGroupByOutputType = {
    id: number
    titulo: string
    descripcion: string
    variante: string
    parqueId: number
    _count: AnuncioCountAggregateOutputType | null
    _avg: AnuncioAvgAggregateOutputType | null
    _sum: AnuncioSumAggregateOutputType | null
    _min: AnuncioMinAggregateOutputType | null
    _max: AnuncioMaxAggregateOutputType | null
  }

  type GetAnuncioGroupByPayload<T extends AnuncioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AnuncioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnuncioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnuncioGroupByOutputType[P]>
            : GetScalarType<T[P], AnuncioGroupByOutputType[P]>
        }
      >
    >


  export type AnuncioSelect = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    variante?: boolean
    parque?: boolean | ParqueArgs
    parqueId?: boolean
  }

  export type AnuncioInclude = {
    parque?: boolean | ParqueArgs
  }

  export type AnuncioGetPayload<
    S extends boolean | null | undefined | AnuncioArgs,
    U = keyof S
      > = S extends true
        ? Anuncio
    : S extends undefined
    ? never
    : S extends AnuncioArgs | AnuncioFindManyArgs
    ?'include' extends U
    ? Anuncio  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :  P extends keyof Anuncio ? Anuncio[P] : never
  } 
    : Anuncio
  : Anuncio


  type AnuncioCountArgs = Merge<
    Omit<AnuncioFindManyArgs, 'select' | 'include'> & {
      select?: AnuncioCountAggregateInputType | true
    }
  >

  export interface AnuncioDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Anuncio that matches the filter.
     * @param {AnuncioFindUniqueArgs} args - Arguments to find a Anuncio
     * @example
     * // Get one Anuncio
     * const anuncio = await prisma.anuncio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnuncioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnuncioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Anuncio'> extends True ? CheckSelect<T, Prisma__AnuncioClient<Anuncio>, Prisma__AnuncioClient<AnuncioGetPayload<T>>> : CheckSelect<T, Prisma__AnuncioClient<Anuncio | null >, Prisma__AnuncioClient<AnuncioGetPayload<T> | null >>

    /**
     * Find the first Anuncio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnuncioFindFirstArgs} args - Arguments to find a Anuncio
     * @example
     * // Get one Anuncio
     * const anuncio = await prisma.anuncio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnuncioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnuncioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Anuncio'> extends True ? CheckSelect<T, Prisma__AnuncioClient<Anuncio>, Prisma__AnuncioClient<AnuncioGetPayload<T>>> : CheckSelect<T, Prisma__AnuncioClient<Anuncio | null >, Prisma__AnuncioClient<AnuncioGetPayload<T> | null >>

    /**
     * Find zero or more Anuncios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnuncioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anuncios
     * const anuncios = await prisma.anuncio.findMany()
     * 
     * // Get first 10 Anuncios
     * const anuncios = await prisma.anuncio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anuncioWithIdOnly = await prisma.anuncio.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnuncioFindManyArgs>(
      args?: SelectSubset<T, AnuncioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Anuncio>>, PrismaPromise<Array<AnuncioGetPayload<T>>>>

    /**
     * Create a Anuncio.
     * @param {AnuncioCreateArgs} args - Arguments to create a Anuncio.
     * @example
     * // Create one Anuncio
     * const Anuncio = await prisma.anuncio.create({
     *   data: {
     *     // ... data to create a Anuncio
     *   }
     * })
     * 
    **/
    create<T extends AnuncioCreateArgs>(
      args: SelectSubset<T, AnuncioCreateArgs>
    ): CheckSelect<T, Prisma__AnuncioClient<Anuncio>, Prisma__AnuncioClient<AnuncioGetPayload<T>>>

    /**
     * Create many Anuncios.
     *     @param {AnuncioCreateManyArgs} args - Arguments to create many Anuncios.
     *     @example
     *     // Create many Anuncios
     *     const anuncio = await prisma.anuncio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnuncioCreateManyArgs>(
      args?: SelectSubset<T, AnuncioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Anuncio.
     * @param {AnuncioDeleteArgs} args - Arguments to delete one Anuncio.
     * @example
     * // Delete one Anuncio
     * const Anuncio = await prisma.anuncio.delete({
     *   where: {
     *     // ... filter to delete one Anuncio
     *   }
     * })
     * 
    **/
    delete<T extends AnuncioDeleteArgs>(
      args: SelectSubset<T, AnuncioDeleteArgs>
    ): CheckSelect<T, Prisma__AnuncioClient<Anuncio>, Prisma__AnuncioClient<AnuncioGetPayload<T>>>

    /**
     * Update one Anuncio.
     * @param {AnuncioUpdateArgs} args - Arguments to update one Anuncio.
     * @example
     * // Update one Anuncio
     * const anuncio = await prisma.anuncio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnuncioUpdateArgs>(
      args: SelectSubset<T, AnuncioUpdateArgs>
    ): CheckSelect<T, Prisma__AnuncioClient<Anuncio>, Prisma__AnuncioClient<AnuncioGetPayload<T>>>

    /**
     * Delete zero or more Anuncios.
     * @param {AnuncioDeleteManyArgs} args - Arguments to filter Anuncios to delete.
     * @example
     * // Delete a few Anuncios
     * const { count } = await prisma.anuncio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnuncioDeleteManyArgs>(
      args?: SelectSubset<T, AnuncioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anuncios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnuncioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anuncios
     * const anuncio = await prisma.anuncio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnuncioUpdateManyArgs>(
      args: SelectSubset<T, AnuncioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Anuncio.
     * @param {AnuncioUpsertArgs} args - Arguments to update or create a Anuncio.
     * @example
     * // Update or create a Anuncio
     * const anuncio = await prisma.anuncio.upsert({
     *   create: {
     *     // ... data to create a Anuncio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anuncio we want to update
     *   }
     * })
    **/
    upsert<T extends AnuncioUpsertArgs>(
      args: SelectSubset<T, AnuncioUpsertArgs>
    ): CheckSelect<T, Prisma__AnuncioClient<Anuncio>, Prisma__AnuncioClient<AnuncioGetPayload<T>>>

    /**
     * Count the number of Anuncios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnuncioCountArgs} args - Arguments to filter Anuncios to count.
     * @example
     * // Count the number of Anuncios
     * const count = await prisma.anuncio.count({
     *   where: {
     *     // ... the filter for the Anuncios we want to count
     *   }
     * })
    **/
    count<T extends AnuncioCountArgs>(
      args?: Subset<T, AnuncioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnuncioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anuncio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnuncioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnuncioAggregateArgs>(args: Subset<T, AnuncioAggregateArgs>): PrismaPromise<GetAnuncioAggregateType<T>>

    /**
     * Group by Anuncio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnuncioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnuncioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnuncioGroupByArgs['orderBy'] }
        : { orderBy?: AnuncioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnuncioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnuncioGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anuncio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnuncioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Anuncio findUnique
   */
  export type AnuncioFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * Throw an Error if a Anuncio can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Anuncio to fetch.
     * 
    **/
    where: AnuncioWhereUniqueInput
  }


  /**
   * Anuncio findFirst
   */
  export type AnuncioFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * Throw an Error if a Anuncio can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Anuncio to fetch.
     * 
    **/
    where?: AnuncioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anuncios to fetch.
     * 
    **/
    orderBy?: Enumerable<AnuncioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anuncios.
     * 
    **/
    cursor?: AnuncioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anuncios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anuncios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anuncios.
     * 
    **/
    distinct?: Enumerable<AnuncioScalarFieldEnum>
  }


  /**
   * Anuncio findMany
   */
  export type AnuncioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * Filter, which Anuncios to fetch.
     * 
    **/
    where?: AnuncioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anuncios to fetch.
     * 
    **/
    orderBy?: Enumerable<AnuncioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anuncios.
     * 
    **/
    cursor?: AnuncioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anuncios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anuncios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AnuncioScalarFieldEnum>
  }


  /**
   * Anuncio create
   */
  export type AnuncioCreateArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * The data needed to create a Anuncio.
     * 
    **/
    data: XOR<AnuncioCreateInput, AnuncioUncheckedCreateInput>
  }


  /**
   * Anuncio createMany
   */
  export type AnuncioCreateManyArgs = {
    /**
     * The data used to create many Anuncios.
     * 
    **/
    data: Enumerable<AnuncioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Anuncio update
   */
  export type AnuncioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * The data needed to update a Anuncio.
     * 
    **/
    data: XOR<AnuncioUpdateInput, AnuncioUncheckedUpdateInput>
    /**
     * Choose, which Anuncio to update.
     * 
    **/
    where: AnuncioWhereUniqueInput
  }


  /**
   * Anuncio updateMany
   */
  export type AnuncioUpdateManyArgs = {
    /**
     * The data used to update Anuncios.
     * 
    **/
    data: XOR<AnuncioUpdateManyMutationInput, AnuncioUncheckedUpdateManyInput>
    /**
     * Filter which Anuncios to update
     * 
    **/
    where?: AnuncioWhereInput
  }


  /**
   * Anuncio upsert
   */
  export type AnuncioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * The filter to search for the Anuncio to update in case it exists.
     * 
    **/
    where: AnuncioWhereUniqueInput
    /**
     * In case the Anuncio found by the `where` argument doesn't exist, create a new Anuncio with this data.
     * 
    **/
    create: XOR<AnuncioCreateInput, AnuncioUncheckedCreateInput>
    /**
     * In case the Anuncio was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AnuncioUpdateInput, AnuncioUncheckedUpdateInput>
  }


  /**
   * Anuncio delete
   */
  export type AnuncioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
    /**
     * Filter which Anuncio to delete.
     * 
    **/
    where: AnuncioWhereUniqueInput
  }


  /**
   * Anuncio deleteMany
   */
  export type AnuncioDeleteManyArgs = {
    /**
     * Filter which Anuncios to delete
     * 
    **/
    where?: AnuncioWhereInput
  }


  /**
   * Anuncio without action
   */
  export type AnuncioArgs = {
    /**
     * Select specific fields to fetch from the Anuncio
     * 
    **/
    select?: AnuncioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnuncioInclude | null
  }



  /**
   * Model Horario
   */


  export type AggregateHorario = {
    _count: HorarioCountAggregateOutputType | null
    _avg: HorarioAvgAggregateOutputType | null
    _sum: HorarioSumAggregateOutputType | null
    _min: HorarioMinAggregateOutputType | null
    _max: HorarioMaxAggregateOutputType | null
  }

  export type HorarioAvgAggregateOutputType = {
    id: number | null
    parqueId: number | null
  }

  export type HorarioSumAggregateOutputType = {
    id: number | null
    parqueId: number | null
  }

  export type HorarioMinAggregateOutputType = {
    id: number | null
    dias: string | null
    horaAbrir: string | null
    horaCerrar: string | null
    parqueId: number | null
  }

  export type HorarioMaxAggregateOutputType = {
    id: number | null
    dias: string | null
    horaAbrir: string | null
    horaCerrar: string | null
    parqueId: number | null
  }

  export type HorarioCountAggregateOutputType = {
    id: number
    dias: number
    horaAbrir: number
    horaCerrar: number
    parqueId: number
    _all: number
  }


  export type HorarioAvgAggregateInputType = {
    id?: true
    parqueId?: true
  }

  export type HorarioSumAggregateInputType = {
    id?: true
    parqueId?: true
  }

  export type HorarioMinAggregateInputType = {
    id?: true
    dias?: true
    horaAbrir?: true
    horaCerrar?: true
    parqueId?: true
  }

  export type HorarioMaxAggregateInputType = {
    id?: true
    dias?: true
    horaAbrir?: true
    horaCerrar?: true
    parqueId?: true
  }

  export type HorarioCountAggregateInputType = {
    id?: true
    dias?: true
    horaAbrir?: true
    horaCerrar?: true
    parqueId?: true
    _all?: true
  }

  export type HorarioAggregateArgs = {
    /**
     * Filter which Horario to aggregate.
     * 
    **/
    where?: HorarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     * 
    **/
    orderBy?: Enumerable<HorarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: HorarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Horarios
    **/
    _count?: true | HorarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HorarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HorarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorarioMaxAggregateInputType
  }

  export type GetHorarioAggregateType<T extends HorarioAggregateArgs> = {
        [P in keyof T & keyof AggregateHorario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorario[P]>
      : GetScalarType<T[P], AggregateHorario[P]>
  }




  export type HorarioGroupByArgs = {
    where?: HorarioWhereInput
    orderBy?: Enumerable<HorarioOrderByWithAggregationInput>
    by: Array<HorarioScalarFieldEnum>
    having?: HorarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorarioCountAggregateInputType | true
    _avg?: HorarioAvgAggregateInputType
    _sum?: HorarioSumAggregateInputType
    _min?: HorarioMinAggregateInputType
    _max?: HorarioMaxAggregateInputType
  }


  export type HorarioGroupByOutputType = {
    id: number
    dias: string
    horaAbrir: string
    horaCerrar: string
    parqueId: number
    _count: HorarioCountAggregateOutputType | null
    _avg: HorarioAvgAggregateOutputType | null
    _sum: HorarioSumAggregateOutputType | null
    _min: HorarioMinAggregateOutputType | null
    _max: HorarioMaxAggregateOutputType | null
  }

  type GetHorarioGroupByPayload<T extends HorarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<HorarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorarioGroupByOutputType[P]>
            : GetScalarType<T[P], HorarioGroupByOutputType[P]>
        }
      >
    >


  export type HorarioSelect = {
    id?: boolean
    dias?: boolean
    horaAbrir?: boolean
    horaCerrar?: boolean
    parque?: boolean | ParqueArgs
    parqueId?: boolean
  }

  export type HorarioInclude = {
    parque?: boolean | ParqueArgs
  }

  export type HorarioGetPayload<
    S extends boolean | null | undefined | HorarioArgs,
    U = keyof S
      > = S extends true
        ? Horario
    : S extends undefined
    ? never
    : S extends HorarioArgs | HorarioFindManyArgs
    ?'include' extends U
    ? Horario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'parque' ? ParqueGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'parque' ? ParqueGetPayload<S['select'][P]> :  P extends keyof Horario ? Horario[P] : never
  } 
    : Horario
  : Horario


  type HorarioCountArgs = Merge<
    Omit<HorarioFindManyArgs, 'select' | 'include'> & {
      select?: HorarioCountAggregateInputType | true
    }
  >

  export interface HorarioDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Horario that matches the filter.
     * @param {HorarioFindUniqueArgs} args - Arguments to find a Horario
     * @example
     * // Get one Horario
     * const horario = await prisma.horario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HorarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HorarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Horario'> extends True ? CheckSelect<T, Prisma__HorarioClient<Horario>, Prisma__HorarioClient<HorarioGetPayload<T>>> : CheckSelect<T, Prisma__HorarioClient<Horario | null >, Prisma__HorarioClient<HorarioGetPayload<T> | null >>

    /**
     * Find the first Horario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioFindFirstArgs} args - Arguments to find a Horario
     * @example
     * // Get one Horario
     * const horario = await prisma.horario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HorarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HorarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Horario'> extends True ? CheckSelect<T, Prisma__HorarioClient<Horario>, Prisma__HorarioClient<HorarioGetPayload<T>>> : CheckSelect<T, Prisma__HorarioClient<Horario | null >, Prisma__HorarioClient<HorarioGetPayload<T> | null >>

    /**
     * Find zero or more Horarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horarios
     * const horarios = await prisma.horario.findMany()
     * 
     * // Get first 10 Horarios
     * const horarios = await prisma.horario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const horarioWithIdOnly = await prisma.horario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HorarioFindManyArgs>(
      args?: SelectSubset<T, HorarioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Horario>>, PrismaPromise<Array<HorarioGetPayload<T>>>>

    /**
     * Create a Horario.
     * @param {HorarioCreateArgs} args - Arguments to create a Horario.
     * @example
     * // Create one Horario
     * const Horario = await prisma.horario.create({
     *   data: {
     *     // ... data to create a Horario
     *   }
     * })
     * 
    **/
    create<T extends HorarioCreateArgs>(
      args: SelectSubset<T, HorarioCreateArgs>
    ): CheckSelect<T, Prisma__HorarioClient<Horario>, Prisma__HorarioClient<HorarioGetPayload<T>>>

    /**
     * Create many Horarios.
     *     @param {HorarioCreateManyArgs} args - Arguments to create many Horarios.
     *     @example
     *     // Create many Horarios
     *     const horario = await prisma.horario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HorarioCreateManyArgs>(
      args?: SelectSubset<T, HorarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Horario.
     * @param {HorarioDeleteArgs} args - Arguments to delete one Horario.
     * @example
     * // Delete one Horario
     * const Horario = await prisma.horario.delete({
     *   where: {
     *     // ... filter to delete one Horario
     *   }
     * })
     * 
    **/
    delete<T extends HorarioDeleteArgs>(
      args: SelectSubset<T, HorarioDeleteArgs>
    ): CheckSelect<T, Prisma__HorarioClient<Horario>, Prisma__HorarioClient<HorarioGetPayload<T>>>

    /**
     * Update one Horario.
     * @param {HorarioUpdateArgs} args - Arguments to update one Horario.
     * @example
     * // Update one Horario
     * const horario = await prisma.horario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HorarioUpdateArgs>(
      args: SelectSubset<T, HorarioUpdateArgs>
    ): CheckSelect<T, Prisma__HorarioClient<Horario>, Prisma__HorarioClient<HorarioGetPayload<T>>>

    /**
     * Delete zero or more Horarios.
     * @param {HorarioDeleteManyArgs} args - Arguments to filter Horarios to delete.
     * @example
     * // Delete a few Horarios
     * const { count } = await prisma.horario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HorarioDeleteManyArgs>(
      args?: SelectSubset<T, HorarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horarios
     * const horario = await prisma.horario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HorarioUpdateManyArgs>(
      args: SelectSubset<T, HorarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Horario.
     * @param {HorarioUpsertArgs} args - Arguments to update or create a Horario.
     * @example
     * // Update or create a Horario
     * const horario = await prisma.horario.upsert({
     *   create: {
     *     // ... data to create a Horario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horario we want to update
     *   }
     * })
    **/
    upsert<T extends HorarioUpsertArgs>(
      args: SelectSubset<T, HorarioUpsertArgs>
    ): CheckSelect<T, Prisma__HorarioClient<Horario>, Prisma__HorarioClient<HorarioGetPayload<T>>>

    /**
     * Count the number of Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioCountArgs} args - Arguments to filter Horarios to count.
     * @example
     * // Count the number of Horarios
     * const count = await prisma.horario.count({
     *   where: {
     *     // ... the filter for the Horarios we want to count
     *   }
     * })
    **/
    count<T extends HorarioCountArgs>(
      args?: Subset<T, HorarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorarioAggregateArgs>(args: Subset<T, HorarioAggregateArgs>): PrismaPromise<GetHorarioAggregateType<T>>

    /**
     * Group by Horario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HorarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HorarioGroupByArgs['orderBy'] }
        : { orderBy?: HorarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HorarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorarioGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Horario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HorarioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parque<T extends ParqueArgs = {}>(args?: Subset<T, ParqueArgs>): CheckSelect<T, Prisma__ParqueClient<Parque | null >, Prisma__ParqueClient<ParqueGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Horario findUnique
   */
  export type HorarioFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * Throw an Error if a Horario can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Horario to fetch.
     * 
    **/
    where: HorarioWhereUniqueInput
  }


  /**
   * Horario findFirst
   */
  export type HorarioFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * Throw an Error if a Horario can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Horario to fetch.
     * 
    **/
    where?: HorarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     * 
    **/
    orderBy?: Enumerable<HorarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horarios.
     * 
    **/
    cursor?: HorarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horarios.
     * 
    **/
    distinct?: Enumerable<HorarioScalarFieldEnum>
  }


  /**
   * Horario findMany
   */
  export type HorarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * Filter, which Horarios to fetch.
     * 
    **/
    where?: HorarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horarios to fetch.
     * 
    **/
    orderBy?: Enumerable<HorarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Horarios.
     * 
    **/
    cursor?: HorarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<HorarioScalarFieldEnum>
  }


  /**
   * Horario create
   */
  export type HorarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * The data needed to create a Horario.
     * 
    **/
    data: XOR<HorarioCreateInput, HorarioUncheckedCreateInput>
  }


  /**
   * Horario createMany
   */
  export type HorarioCreateManyArgs = {
    /**
     * The data used to create many Horarios.
     * 
    **/
    data: Enumerable<HorarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Horario update
   */
  export type HorarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * The data needed to update a Horario.
     * 
    **/
    data: XOR<HorarioUpdateInput, HorarioUncheckedUpdateInput>
    /**
     * Choose, which Horario to update.
     * 
    **/
    where: HorarioWhereUniqueInput
  }


  /**
   * Horario updateMany
   */
  export type HorarioUpdateManyArgs = {
    /**
     * The data used to update Horarios.
     * 
    **/
    data: XOR<HorarioUpdateManyMutationInput, HorarioUncheckedUpdateManyInput>
    /**
     * Filter which Horarios to update
     * 
    **/
    where?: HorarioWhereInput
  }


  /**
   * Horario upsert
   */
  export type HorarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * The filter to search for the Horario to update in case it exists.
     * 
    **/
    where: HorarioWhereUniqueInput
    /**
     * In case the Horario found by the `where` argument doesn't exist, create a new Horario with this data.
     * 
    **/
    create: XOR<HorarioCreateInput, HorarioUncheckedCreateInput>
    /**
     * In case the Horario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<HorarioUpdateInput, HorarioUncheckedUpdateInput>
  }


  /**
   * Horario delete
   */
  export type HorarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
    /**
     * Filter which Horario to delete.
     * 
    **/
    where: HorarioWhereUniqueInput
  }


  /**
   * Horario deleteMany
   */
  export type HorarioDeleteManyArgs = {
    /**
     * Filter which Horarios to delete
     * 
    **/
    where?: HorarioWhereInput
  }


  /**
   * Horario without action
   */
  export type HorarioArgs = {
    /**
     * Select specific fields to fetch from the Horario
     * 
    **/
    select?: HorarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HorarioInclude | null
  }



  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    email: string | null
    password: string | null
    role: Role | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    email: string | null
    password: string | null
    role: Role | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    email: number
    password: number
    role: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    password?: true
    role?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    password?: true
    role?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which Usuario to aggregate.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: UsuarioWhereInput
    orderBy?: Enumerable<UsuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    email: string
    password: string
    role: Role
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect = {
    id?: boolean
    nombre?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }

  export type UsuarioGetPayload<
    S extends boolean | null | undefined | UsuarioArgs,
    U = keyof S
      > = S extends true
        ? Usuario
    : S extends undefined
    ? never
    : S extends UsuarioArgs | UsuarioFindManyArgs
    ?'include' extends U
    ? Usuario 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Usuario ? Usuario[P] : never
  } 
    : Usuario
  : Usuario


  type UsuarioCountArgs = Merge<
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface UsuarioDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null >, Prisma__UsuarioClient<UsuarioGetPayload<T> | null >>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs>(
      args?: SelectSubset<T, UsuarioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs>(
      args: SelectSubset<T, UsuarioCreateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs>(
      args?: SelectSubset<T, UsuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs>(
      args: SelectSubset<T, UsuarioDeleteArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs>(
      args: SelectSubset<T, UsuarioUpdateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: SelectSubset<T, UsuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs>(
      args: SelectSubset<T, UsuarioUpsertArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Throw an Error if a Usuario can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Throw an Error if a Usuario can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Filter, which Usuarios to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * The data needed to create a Usuario.
     * 
    **/
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs = {
    /**
     * The data used to create many Usuarios.
     * 
    **/
    data: Enumerable<UsuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * The data needed to update a Usuario.
     * 
    **/
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs = {
    /**
     * The data used to update Usuarios.
     * 
    **/
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     * 
    **/
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     * 
    **/
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Filter which Usuario to delete.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs = {
    /**
     * Filter which Usuarios to delete
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario without action
   */
  export type UsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ParqueScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    imagen: 'imagen',
    direccion: 'direccion',
    latitud: 'latitud',
    longitud: 'longitud',
    fechaDecreto: 'fechaDecreto',
    superficieTerrestre: 'superficieTerrestre',
    superficieMarina: 'superficieMarina',
    clicks: 'clicks'
  };

  export type ParqueScalarFieldEnum = (typeof ParqueScalarFieldEnum)[keyof typeof ParqueScalarFieldEnum]


  export const EstadoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type EstadoScalarFieldEnum = (typeof EstadoScalarFieldEnum)[keyof typeof EstadoScalarFieldEnum]


  export const EstadoParqueScalarFieldEnum: {
    parqueId: 'parqueId',
    estadoId: 'estadoId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type EstadoParqueScalarFieldEnum = (typeof EstadoParqueScalarFieldEnum)[keyof typeof EstadoParqueScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const RegionParqueScalarFieldEnum: {
    parqueId: 'parqueId',
    regionId: 'regionId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type RegionParqueScalarFieldEnum = (typeof RegionParqueScalarFieldEnum)[keyof typeof RegionParqueScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const CategoriaParqueScalarFieldEnum: {
    parqueId: 'parqueId',
    categoriaId: 'categoriaId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type CategoriaParqueScalarFieldEnum = (typeof CategoriaParqueScalarFieldEnum)[keyof typeof CategoriaParqueScalarFieldEnum]


  export const FloraScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    imagen: 'imagen',
    descripcion: 'descripcion'
  };

  export type FloraScalarFieldEnum = (typeof FloraScalarFieldEnum)[keyof typeof FloraScalarFieldEnum]


  export const FloraParqueScalarFieldEnum: {
    parqueId: 'parqueId',
    floraId: 'floraId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type FloraParqueScalarFieldEnum = (typeof FloraParqueScalarFieldEnum)[keyof typeof FloraParqueScalarFieldEnum]


  export const FaunaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    imagen: 'imagen',
    descripcion: 'descripcion'
  };

  export type FaunaScalarFieldEnum = (typeof FaunaScalarFieldEnum)[keyof typeof FaunaScalarFieldEnum]


  export const FaunaParqueScalarFieldEnum: {
    parqueId: 'parqueId',
    faunaID: 'faunaID',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type FaunaParqueScalarFieldEnum = (typeof FaunaParqueScalarFieldEnum)[keyof typeof FaunaParqueScalarFieldEnum]


  export const ActividadScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type ActividadScalarFieldEnum = (typeof ActividadScalarFieldEnum)[keyof typeof ActividadScalarFieldEnum]


  export const ActividadParqueScalarFieldEnum: {
    parqueId: 'parqueId',
    actividadId: 'actividadId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type ActividadParqueScalarFieldEnum = (typeof ActividadParqueScalarFieldEnum)[keyof typeof ActividadParqueScalarFieldEnum]


  export const AnuncioScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    variante: 'variante',
    parqueId: 'parqueId'
  };

  export type AnuncioScalarFieldEnum = (typeof AnuncioScalarFieldEnum)[keyof typeof AnuncioScalarFieldEnum]


  export const HorarioScalarFieldEnum: {
    id: 'id',
    dias: 'dias',
    horaAbrir: 'horaAbrir',
    horaCerrar: 'horaCerrar',
    parqueId: 'parqueId'
  };

  export type HorarioScalarFieldEnum = (typeof HorarioScalarFieldEnum)[keyof typeof HorarioScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type ParqueWhereInput = {
    AND?: Enumerable<ParqueWhereInput>
    OR?: Enumerable<ParqueWhereInput>
    NOT?: Enumerable<ParqueWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    imagen?: StringFilter | string
    direccion?: StringFilter | string
    latitud?: FloatFilter | number
    longitud?: FloatFilter | number
    fechaDecreto?: StringFilter | string
    superficieTerrestre?: FloatFilter | number
    superficieMarina?: FloatFilter | number
    clicks?: IntFilter | number
    anuncios?: AnuncioListRelationFilter
    horario?: HorarioListRelationFilter
    actividades?: ActividadParqueListRelationFilter
    flora?: FloraParqueListRelationFilter
    fauna?: FaunaParqueListRelationFilter
    categoria?: CategoriaParqueListRelationFilter
    estado?: EstadoParqueListRelationFilter
    region?: RegionParqueListRelationFilter
  }

  export type ParqueOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagen?: SortOrder
    direccion?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    fechaDecreto?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
    anuncios?: AnuncioOrderByRelationAggregateInput
    horario?: HorarioOrderByRelationAggregateInput
    actividades?: ActividadParqueOrderByRelationAggregateInput
    flora?: FloraParqueOrderByRelationAggregateInput
    fauna?: FaunaParqueOrderByRelationAggregateInput
    categoria?: CategoriaParqueOrderByRelationAggregateInput
    estado?: EstadoParqueOrderByRelationAggregateInput
    region?: RegionParqueOrderByRelationAggregateInput
  }

  export type ParqueWhereUniqueInput = {
    id?: number
  }

  export type ParqueOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagen?: SortOrder
    direccion?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    fechaDecreto?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
    _count?: ParqueCountOrderByAggregateInput
    _avg?: ParqueAvgOrderByAggregateInput
    _max?: ParqueMaxOrderByAggregateInput
    _min?: ParqueMinOrderByAggregateInput
    _sum?: ParqueSumOrderByAggregateInput
  }

  export type ParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<ParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ParqueScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    imagen?: StringWithAggregatesFilter | string
    direccion?: StringWithAggregatesFilter | string
    latitud?: FloatWithAggregatesFilter | number
    longitud?: FloatWithAggregatesFilter | number
    fechaDecreto?: StringWithAggregatesFilter | string
    superficieTerrestre?: FloatWithAggregatesFilter | number
    superficieMarina?: FloatWithAggregatesFilter | number
    clicks?: IntWithAggregatesFilter | number
  }

  export type EstadoWhereInput = {
    AND?: Enumerable<EstadoWhereInput>
    OR?: Enumerable<EstadoWhereInput>
    NOT?: Enumerable<EstadoWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    parque?: EstadoParqueListRelationFilter
  }

  export type EstadoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    parque?: EstadoParqueOrderByRelationAggregateInput
  }

  export type EstadoWhereUniqueInput = {
    id?: number
  }

  export type EstadoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: EstadoCountOrderByAggregateInput
    _avg?: EstadoAvgOrderByAggregateInput
    _max?: EstadoMaxOrderByAggregateInput
    _min?: EstadoMinOrderByAggregateInput
    _sum?: EstadoSumOrderByAggregateInput
  }

  export type EstadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EstadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<EstadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EstadoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
  }

  export type EstadoParqueWhereInput = {
    AND?: Enumerable<EstadoParqueWhereInput>
    OR?: Enumerable<EstadoParqueWhereInput>
    NOT?: Enumerable<EstadoParqueWhereInput>
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
    estado?: XOR<EstadoRelationFilter, EstadoWhereInput>
    estadoId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type EstadoParqueOrderByWithRelationInput = {
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
    estado?: EstadoOrderByWithRelationInput
    estadoId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type EstadoParqueWhereUniqueInput = {
    parqueId_estadoId?: EstadoParqueParqueIdEstadoIdCompoundUniqueInput
  }

  export type EstadoParqueOrderByWithAggregationInput = {
    parqueId?: SortOrder
    estadoId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: EstadoParqueCountOrderByAggregateInput
    _avg?: EstadoParqueAvgOrderByAggregateInput
    _max?: EstadoParqueMaxOrderByAggregateInput
    _min?: EstadoParqueMinOrderByAggregateInput
    _sum?: EstadoParqueSumOrderByAggregateInput
  }

  export type EstadoParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EstadoParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<EstadoParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EstadoParqueScalarWhereWithAggregatesInput>
    parqueId?: IntWithAggregatesFilter | number
    estadoId?: IntWithAggregatesFilter | number
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedBy?: StringWithAggregatesFilter | string
  }

  export type RegionWhereInput = {
    AND?: Enumerable<RegionWhereInput>
    OR?: Enumerable<RegionWhereInput>
    NOT?: Enumerable<RegionWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    parque?: RegionParqueListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    parque?: RegionParqueOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = {
    id?: number
  }

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
  }

  export type RegionParqueWhereInput = {
    AND?: Enumerable<RegionParqueWhereInput>
    OR?: Enumerable<RegionParqueWhereInput>
    NOT?: Enumerable<RegionParqueWhereInput>
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    regionId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type RegionParqueOrderByWithRelationInput = {
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
    region?: RegionOrderByWithRelationInput
    regionId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type RegionParqueWhereUniqueInput = {
    parqueId_regionId?: RegionParqueParqueIdRegionIdCompoundUniqueInput
  }

  export type RegionParqueOrderByWithAggregationInput = {
    parqueId?: SortOrder
    regionId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: RegionParqueCountOrderByAggregateInput
    _avg?: RegionParqueAvgOrderByAggregateInput
    _max?: RegionParqueMaxOrderByAggregateInput
    _min?: RegionParqueMinOrderByAggregateInput
    _sum?: RegionParqueSumOrderByAggregateInput
  }

  export type RegionParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegionParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegionParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegionParqueScalarWhereWithAggregatesInput>
    parqueId?: IntWithAggregatesFilter | number
    regionId?: IntWithAggregatesFilter | number
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedBy?: StringWithAggregatesFilter | string
  }

  export type CategoriaWhereInput = {
    AND?: Enumerable<CategoriaWhereInput>
    OR?: Enumerable<CategoriaWhereInput>
    NOT?: Enumerable<CategoriaWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    parque?: CategoriaParqueListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    parque?: CategoriaParqueOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = {
    id?: number
  }

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
  }

  export type CategoriaParqueWhereInput = {
    AND?: Enumerable<CategoriaParqueWhereInput>
    OR?: Enumerable<CategoriaParqueWhereInput>
    NOT?: Enumerable<CategoriaParqueWhereInput>
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
    categoria?: XOR<CategoriaRelationFilter, CategoriaWhereInput>
    categoriaId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type CategoriaParqueOrderByWithRelationInput = {
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
    categoria?: CategoriaOrderByWithRelationInput
    categoriaId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type CategoriaParqueWhereUniqueInput = {
    parqueId_categoriaId?: CategoriaParqueParqueIdCategoriaIdCompoundUniqueInput
  }

  export type CategoriaParqueOrderByWithAggregationInput = {
    parqueId?: SortOrder
    categoriaId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: CategoriaParqueCountOrderByAggregateInput
    _avg?: CategoriaParqueAvgOrderByAggregateInput
    _max?: CategoriaParqueMaxOrderByAggregateInput
    _min?: CategoriaParqueMinOrderByAggregateInput
    _sum?: CategoriaParqueSumOrderByAggregateInput
  }

  export type CategoriaParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoriaParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoriaParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoriaParqueScalarWhereWithAggregatesInput>
    parqueId?: IntWithAggregatesFilter | number
    categoriaId?: IntWithAggregatesFilter | number
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedBy?: StringWithAggregatesFilter | string
  }

  export type FloraWhereInput = {
    AND?: Enumerable<FloraWhereInput>
    OR?: Enumerable<FloraWhereInput>
    NOT?: Enumerable<FloraWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    imagen?: StringFilter | string
    descripcion?: StringFilter | string
    parques?: FloraParqueListRelationFilter
  }

  export type FloraOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
    parques?: FloraParqueOrderByRelationAggregateInput
  }

  export type FloraWhereUniqueInput = {
    id?: number
  }

  export type FloraOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
    _count?: FloraCountOrderByAggregateInput
    _avg?: FloraAvgOrderByAggregateInput
    _max?: FloraMaxOrderByAggregateInput
    _min?: FloraMinOrderByAggregateInput
    _sum?: FloraSumOrderByAggregateInput
  }

  export type FloraScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FloraScalarWhereWithAggregatesInput>
    OR?: Enumerable<FloraScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FloraScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    imagen?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
  }

  export type FloraParqueWhereInput = {
    AND?: Enumerable<FloraParqueWhereInput>
    OR?: Enumerable<FloraParqueWhereInput>
    NOT?: Enumerable<FloraParqueWhereInput>
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
    flora?: XOR<FloraRelationFilter, FloraWhereInput>
    floraId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type FloraParqueOrderByWithRelationInput = {
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
    flora?: FloraOrderByWithRelationInput
    floraId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FloraParqueWhereUniqueInput = {
    parqueId_floraId?: FloraParqueParqueIdFloraIdCompoundUniqueInput
  }

  export type FloraParqueOrderByWithAggregationInput = {
    parqueId?: SortOrder
    floraId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: FloraParqueCountOrderByAggregateInput
    _avg?: FloraParqueAvgOrderByAggregateInput
    _max?: FloraParqueMaxOrderByAggregateInput
    _min?: FloraParqueMinOrderByAggregateInput
    _sum?: FloraParqueSumOrderByAggregateInput
  }

  export type FloraParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FloraParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<FloraParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FloraParqueScalarWhereWithAggregatesInput>
    parqueId?: IntWithAggregatesFilter | number
    floraId?: IntWithAggregatesFilter | number
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedBy?: StringWithAggregatesFilter | string
  }

  export type FaunaWhereInput = {
    AND?: Enumerable<FaunaWhereInput>
    OR?: Enumerable<FaunaWhereInput>
    NOT?: Enumerable<FaunaWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    imagen?: StringFilter | string
    descripcion?: StringFilter | string
    parques?: FaunaParqueListRelationFilter
  }

  export type FaunaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
    parques?: FaunaParqueOrderByRelationAggregateInput
  }

  export type FaunaWhereUniqueInput = {
    id?: number
  }

  export type FaunaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
    _count?: FaunaCountOrderByAggregateInput
    _avg?: FaunaAvgOrderByAggregateInput
    _max?: FaunaMaxOrderByAggregateInput
    _min?: FaunaMinOrderByAggregateInput
    _sum?: FaunaSumOrderByAggregateInput
  }

  export type FaunaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FaunaScalarWhereWithAggregatesInput>
    OR?: Enumerable<FaunaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FaunaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    imagen?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
  }

  export type FaunaParqueWhereInput = {
    AND?: Enumerable<FaunaParqueWhereInput>
    OR?: Enumerable<FaunaParqueWhereInput>
    NOT?: Enumerable<FaunaParqueWhereInput>
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
    fauna?: XOR<FaunaRelationFilter, FaunaWhereInput>
    faunaID?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type FaunaParqueOrderByWithRelationInput = {
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
    fauna?: FaunaOrderByWithRelationInput
    faunaID?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FaunaParqueWhereUniqueInput = {
    parqueId_faunaID?: FaunaParqueParqueIdFaunaIDCompoundUniqueInput
  }

  export type FaunaParqueOrderByWithAggregationInput = {
    parqueId?: SortOrder
    faunaID?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: FaunaParqueCountOrderByAggregateInput
    _avg?: FaunaParqueAvgOrderByAggregateInput
    _max?: FaunaParqueMaxOrderByAggregateInput
    _min?: FaunaParqueMinOrderByAggregateInput
    _sum?: FaunaParqueSumOrderByAggregateInput
  }

  export type FaunaParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FaunaParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<FaunaParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FaunaParqueScalarWhereWithAggregatesInput>
    parqueId?: IntWithAggregatesFilter | number
    faunaID?: IntWithAggregatesFilter | number
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedBy?: StringWithAggregatesFilter | string
  }

  export type ActividadWhereInput = {
    AND?: Enumerable<ActividadWhereInput>
    OR?: Enumerable<ActividadWhereInput>
    NOT?: Enumerable<ActividadWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    parques?: ActividadParqueListRelationFilter
  }

  export type ActividadOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    parques?: ActividadParqueOrderByRelationAggregateInput
  }

  export type ActividadWhereUniqueInput = {
    id?: number
  }

  export type ActividadOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: ActividadCountOrderByAggregateInput
    _avg?: ActividadAvgOrderByAggregateInput
    _max?: ActividadMaxOrderByAggregateInput
    _min?: ActividadMinOrderByAggregateInput
    _sum?: ActividadSumOrderByAggregateInput
  }

  export type ActividadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActividadScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActividadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActividadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
  }

  export type ActividadParqueWhereInput = {
    AND?: Enumerable<ActividadParqueWhereInput>
    OR?: Enumerable<ActividadParqueWhereInput>
    NOT?: Enumerable<ActividadParqueWhereInput>
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
    actividad?: XOR<ActividadRelationFilter, ActividadWhereInput>
    actividadId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type ActividadParqueOrderByWithRelationInput = {
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
    actividad?: ActividadOrderByWithRelationInput
    actividadId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type ActividadParqueWhereUniqueInput = {
    parqueId_actividadId?: ActividadParqueParqueIdActividadIdCompoundUniqueInput
  }

  export type ActividadParqueOrderByWithAggregationInput = {
    parqueId?: SortOrder
    actividadId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: ActividadParqueCountOrderByAggregateInput
    _avg?: ActividadParqueAvgOrderByAggregateInput
    _max?: ActividadParqueMaxOrderByAggregateInput
    _min?: ActividadParqueMinOrderByAggregateInput
    _sum?: ActividadParqueSumOrderByAggregateInput
  }

  export type ActividadParqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActividadParqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActividadParqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActividadParqueScalarWhereWithAggregatesInput>
    parqueId?: IntWithAggregatesFilter | number
    actividadId?: IntWithAggregatesFilter | number
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    assignedBy?: StringWithAggregatesFilter | string
  }

  export type AnuncioWhereInput = {
    AND?: Enumerable<AnuncioWhereInput>
    OR?: Enumerable<AnuncioWhereInput>
    NOT?: Enumerable<AnuncioWhereInput>
    id?: IntFilter | number
    titulo?: StringFilter | string
    descripcion?: StringFilter | string
    variante?: StringFilter | string
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
  }

  export type AnuncioOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    variante?: SortOrder
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
  }

  export type AnuncioWhereUniqueInput = {
    id?: number
  }

  export type AnuncioOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    variante?: SortOrder
    parqueId?: SortOrder
    _count?: AnuncioCountOrderByAggregateInput
    _avg?: AnuncioAvgOrderByAggregateInput
    _max?: AnuncioMaxOrderByAggregateInput
    _min?: AnuncioMinOrderByAggregateInput
    _sum?: AnuncioSumOrderByAggregateInput
  }

  export type AnuncioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnuncioScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnuncioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnuncioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titulo?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    variante?: StringWithAggregatesFilter | string
    parqueId?: IntWithAggregatesFilter | number
  }

  export type HorarioWhereInput = {
    AND?: Enumerable<HorarioWhereInput>
    OR?: Enumerable<HorarioWhereInput>
    NOT?: Enumerable<HorarioWhereInput>
    id?: IntFilter | number
    dias?: StringFilter | string
    horaAbrir?: StringFilter | string
    horaCerrar?: StringFilter | string
    parque?: XOR<ParqueRelationFilter, ParqueWhereInput>
    parqueId?: IntFilter | number
  }

  export type HorarioOrderByWithRelationInput = {
    id?: SortOrder
    dias?: SortOrder
    horaAbrir?: SortOrder
    horaCerrar?: SortOrder
    parque?: ParqueOrderByWithRelationInput
    parqueId?: SortOrder
  }

  export type HorarioWhereUniqueInput = {
    id?: number
  }

  export type HorarioOrderByWithAggregationInput = {
    id?: SortOrder
    dias?: SortOrder
    horaAbrir?: SortOrder
    horaCerrar?: SortOrder
    parqueId?: SortOrder
    _count?: HorarioCountOrderByAggregateInput
    _avg?: HorarioAvgOrderByAggregateInput
    _max?: HorarioMaxOrderByAggregateInput
    _min?: HorarioMinOrderByAggregateInput
    _sum?: HorarioSumOrderByAggregateInput
  }

  export type HorarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HorarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<HorarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HorarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    dias?: StringWithAggregatesFilter | string
    horaAbrir?: StringWithAggregatesFilter | string
    horaCerrar?: StringWithAggregatesFilter | string
    parqueId?: IntWithAggregatesFilter | number
  }

  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    role?: EnumRoleFilter | Role
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsuarioWhereUniqueInput = {
    id?: number
  }

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
  }

  export type ParqueCreateInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type ParqueCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
  }

  export type ParqueUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type ParqueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
  }

  export type EstadoCreateInput = {
    nombre: string
    parque?: EstadoParqueCreateNestedManyWithoutEstadoInput
  }

  export type EstadoUncheckedCreateInput = {
    id?: number
    nombre: string
    parque?: EstadoParqueUncheckedCreateNestedManyWithoutEstadoInput
  }

  export type EstadoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    parque?: EstadoParqueUpdateManyWithoutEstadoInput
  }

  export type EstadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    parque?: EstadoParqueUncheckedUpdateManyWithoutEstadoInput
  }

  export type EstadoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type EstadoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueCreateInput = {
    parque: ParqueCreateNestedOneWithoutEstadoInput
    estado: EstadoCreateNestedOneWithoutParqueInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueUncheckedCreateInput = {
    parqueId: number
    estadoId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueUpdateInput = {
    parque?: ParqueUpdateOneRequiredWithoutEstadoInput
    estado?: EstadoUpdateOneRequiredWithoutParqueInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueUncheckedUpdateInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    estadoId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueCreateManyInput = {
    parqueId: number
    estadoId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueUncheckedUpdateManyInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    estadoId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionCreateInput = {
    nombre: string
    parque?: RegionParqueCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    nombre: string
    parque?: RegionParqueUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    parque?: RegionParqueUpdateManyWithoutRegionInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    parque?: RegionParqueUncheckedUpdateManyWithoutRegionInput
  }

  export type RegionCreateManyInput = {
    id?: number
    nombre: string
  }

  export type RegionUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueCreateInput = {
    parque: ParqueCreateNestedOneWithoutRegionInput
    region: RegionCreateNestedOneWithoutParqueInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueUncheckedCreateInput = {
    parqueId: number
    regionId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueUpdateInput = {
    parque?: ParqueUpdateOneRequiredWithoutRegionInput
    region?: RegionUpdateOneRequiredWithoutParqueInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueUncheckedUpdateInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueCreateManyInput = {
    parqueId: number
    regionId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueUncheckedUpdateManyInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateInput = {
    nombre: string
    parque?: CategoriaParqueCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    parque?: CategoriaParqueUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    parque?: CategoriaParqueUpdateManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    parque?: CategoriaParqueUncheckedUpdateManyWithoutCategoriaInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type CategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueCreateInput = {
    parque: ParqueCreateNestedOneWithoutCategoriaInput
    categoria: CategoriaCreateNestedOneWithoutParqueInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueUncheckedCreateInput = {
    parqueId: number
    categoriaId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueUpdateInput = {
    parque?: ParqueUpdateOneRequiredWithoutCategoriaInput
    categoria?: CategoriaUpdateOneRequiredWithoutParqueInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueUncheckedUpdateInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueCreateManyInput = {
    parqueId: number
    categoriaId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueUncheckedUpdateManyInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraCreateInput = {
    nombre: string
    imagen: string
    descripcion: string
    parques?: FloraParqueCreateNestedManyWithoutFloraInput
  }

  export type FloraUncheckedCreateInput = {
    id?: number
    nombre: string
    imagen: string
    descripcion: string
    parques?: FloraParqueUncheckedCreateNestedManyWithoutFloraInput
  }

  export type FloraUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    parques?: FloraParqueUpdateManyWithoutFloraInput
  }

  export type FloraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    parques?: FloraParqueUncheckedUpdateManyWithoutFloraInput
  }

  export type FloraCreateManyInput = {
    id?: number
    nombre: string
    imagen: string
    descripcion: string
  }

  export type FloraUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FloraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueCreateInput = {
    parque: ParqueCreateNestedOneWithoutFloraInput
    flora: FloraCreateNestedOneWithoutParquesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueUncheckedCreateInput = {
    parqueId: number
    floraId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueUpdateInput = {
    parque?: ParqueUpdateOneRequiredWithoutFloraInput
    flora?: FloraUpdateOneRequiredWithoutParquesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueUncheckedUpdateInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    floraId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueCreateManyInput = {
    parqueId: number
    floraId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueUncheckedUpdateManyInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    floraId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaCreateInput = {
    nombre: string
    imagen: string
    descripcion: string
    parques?: FaunaParqueCreateNestedManyWithoutFaunaInput
  }

  export type FaunaUncheckedCreateInput = {
    id?: number
    nombre: string
    imagen: string
    descripcion: string
    parques?: FaunaParqueUncheckedCreateNestedManyWithoutFaunaInput
  }

  export type FaunaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    parques?: FaunaParqueUpdateManyWithoutFaunaInput
  }

  export type FaunaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    parques?: FaunaParqueUncheckedUpdateManyWithoutFaunaInput
  }

  export type FaunaCreateManyInput = {
    id?: number
    nombre: string
    imagen: string
    descripcion: string
  }

  export type FaunaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueCreateInput = {
    parque: ParqueCreateNestedOneWithoutFaunaInput
    fauna: FaunaCreateNestedOneWithoutParquesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueUncheckedCreateInput = {
    parqueId: number
    faunaID: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueUpdateInput = {
    parque?: ParqueUpdateOneRequiredWithoutFaunaInput
    fauna?: FaunaUpdateOneRequiredWithoutParquesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueUncheckedUpdateInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    faunaID?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueCreateManyInput = {
    parqueId: number
    faunaID: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueUncheckedUpdateManyInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    faunaID?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadCreateInput = {
    nombre: string
    parques?: ActividadParqueCreateNestedManyWithoutActividadInput
  }

  export type ActividadUncheckedCreateInput = {
    id?: number
    nombre: string
    parques?: ActividadParqueUncheckedCreateNestedManyWithoutActividadInput
  }

  export type ActividadUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    parques?: ActividadParqueUpdateManyWithoutActividadInput
  }

  export type ActividadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    parques?: ActividadParqueUncheckedUpdateManyWithoutActividadInput
  }

  export type ActividadCreateManyInput = {
    id?: number
    nombre: string
  }

  export type ActividadUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueCreateInput = {
    parque: ParqueCreateNestedOneWithoutActividadesInput
    actividad: ActividadCreateNestedOneWithoutParquesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueUncheckedCreateInput = {
    parqueId: number
    actividadId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueUpdateInput = {
    parque?: ParqueUpdateOneRequiredWithoutActividadesInput
    actividad?: ActividadUpdateOneRequiredWithoutParquesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUncheckedUpdateInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    actividadId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueCreateManyInput = {
    parqueId: number
    actividadId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUncheckedUpdateManyInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    actividadId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnuncioCreateInput = {
    titulo: string
    descripcion: string
    variante: string
    parque: ParqueCreateNestedOneWithoutAnunciosInput
  }

  export type AnuncioUncheckedCreateInput = {
    id?: number
    titulo: string
    descripcion: string
    variante: string
    parqueId: number
  }

  export type AnuncioUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
    parque?: ParqueUpdateOneRequiredWithoutAnunciosInput
  }

  export type AnuncioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
    parqueId?: IntFieldUpdateOperationsInput | number
  }

  export type AnuncioCreateManyInput = {
    id?: number
    titulo: string
    descripcion: string
    variante: string
    parqueId: number
  }

  export type AnuncioUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
  }

  export type AnuncioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
    parqueId?: IntFieldUpdateOperationsInput | number
  }

  export type HorarioCreateInput = {
    dias: string
    horaAbrir: string
    horaCerrar: string
    parque: ParqueCreateNestedOneWithoutHorarioInput
  }

  export type HorarioUncheckedCreateInput = {
    id?: number
    dias: string
    horaAbrir: string
    horaCerrar: string
    parqueId: number
  }

  export type HorarioUpdateInput = {
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
    parque?: ParqueUpdateOneRequiredWithoutHorarioInput
  }

  export type HorarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
    parqueId?: IntFieldUpdateOperationsInput | number
  }

  export type HorarioCreateManyInput = {
    id?: number
    dias: string
    horaAbrir: string
    horaCerrar: string
    parqueId: number
  }

  export type HorarioUpdateManyMutationInput = {
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
  }

  export type HorarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
    parqueId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateInput = {
    nombre: string
    email: string
    password: string
    role?: Role
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    email: string
    password: string
    role?: Role
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    email: string
    password: string
    role?: Role
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type AnuncioListRelationFilter = {
    every?: AnuncioWhereInput
    some?: AnuncioWhereInput
    none?: AnuncioWhereInput
  }

  export type HorarioListRelationFilter = {
    every?: HorarioWhereInput
    some?: HorarioWhereInput
    none?: HorarioWhereInput
  }

  export type ActividadParqueListRelationFilter = {
    every?: ActividadParqueWhereInput
    some?: ActividadParqueWhereInput
    none?: ActividadParqueWhereInput
  }

  export type FloraParqueListRelationFilter = {
    every?: FloraParqueWhereInput
    some?: FloraParqueWhereInput
    none?: FloraParqueWhereInput
  }

  export type FaunaParqueListRelationFilter = {
    every?: FaunaParqueWhereInput
    some?: FaunaParqueWhereInput
    none?: FaunaParqueWhereInput
  }

  export type CategoriaParqueListRelationFilter = {
    every?: CategoriaParqueWhereInput
    some?: CategoriaParqueWhereInput
    none?: CategoriaParqueWhereInput
  }

  export type EstadoParqueListRelationFilter = {
    every?: EstadoParqueWhereInput
    some?: EstadoParqueWhereInput
    none?: EstadoParqueWhereInput
  }

  export type RegionParqueListRelationFilter = {
    every?: RegionParqueWhereInput
    some?: RegionParqueWhereInput
    none?: RegionParqueWhereInput
  }

  export type AnuncioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HorarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActividadParqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FloraParqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FaunaParqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaParqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstadoParqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionParqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParqueCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagen?: SortOrder
    direccion?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    fechaDecreto?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
  }

  export type ParqueAvgOrderByAggregateInput = {
    id?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
  }

  export type ParqueMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagen?: SortOrder
    direccion?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    fechaDecreto?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
  }

  export type ParqueMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagen?: SortOrder
    direccion?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    fechaDecreto?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
  }

  export type ParqueSumOrderByAggregateInput = {
    id?: SortOrder
    latitud?: SortOrder
    longitud?: SortOrder
    superficieTerrestre?: SortOrder
    superficieMarina?: SortOrder
    clicks?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type EstadoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EstadoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EstadoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ParqueRelationFilter = {
    is?: ParqueWhereInput
    isNot?: ParqueWhereInput
  }

  export type EstadoRelationFilter = {
    is?: EstadoWhereInput
    isNot?: EstadoWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type EstadoParqueParqueIdEstadoIdCompoundUniqueInput = {
    parqueId: number
    estadoId: number
  }

  export type EstadoParqueCountOrderByAggregateInput = {
    parqueId?: SortOrder
    estadoId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type EstadoParqueAvgOrderByAggregateInput = {
    parqueId?: SortOrder
    estadoId?: SortOrder
  }

  export type EstadoParqueMaxOrderByAggregateInput = {
    parqueId?: SortOrder
    estadoId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type EstadoParqueMinOrderByAggregateInput = {
    parqueId?: SortOrder
    estadoId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type EstadoParqueSumOrderByAggregateInput = {
    parqueId?: SortOrder
    estadoId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type RegionParqueParqueIdRegionIdCompoundUniqueInput = {
    parqueId: number
    regionId: number
  }

  export type RegionParqueCountOrderByAggregateInput = {
    parqueId?: SortOrder
    regionId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type RegionParqueAvgOrderByAggregateInput = {
    parqueId?: SortOrder
    regionId?: SortOrder
  }

  export type RegionParqueMaxOrderByAggregateInput = {
    parqueId?: SortOrder
    regionId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type RegionParqueMinOrderByAggregateInput = {
    parqueId?: SortOrder
    regionId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type RegionParqueSumOrderByAggregateInput = {
    parqueId?: SortOrder
    regionId?: SortOrder
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaRelationFilter = {
    is?: CategoriaWhereInput
    isNot?: CategoriaWhereInput
  }

  export type CategoriaParqueParqueIdCategoriaIdCompoundUniqueInput = {
    parqueId: number
    categoriaId: number
  }

  export type CategoriaParqueCountOrderByAggregateInput = {
    parqueId?: SortOrder
    categoriaId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type CategoriaParqueAvgOrderByAggregateInput = {
    parqueId?: SortOrder
    categoriaId?: SortOrder
  }

  export type CategoriaParqueMaxOrderByAggregateInput = {
    parqueId?: SortOrder
    categoriaId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type CategoriaParqueMinOrderByAggregateInput = {
    parqueId?: SortOrder
    categoriaId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type CategoriaParqueSumOrderByAggregateInput = {
    parqueId?: SortOrder
    categoriaId?: SortOrder
  }

  export type FloraCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
  }

  export type FloraAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloraMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
  }

  export type FloraMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
  }

  export type FloraSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloraRelationFilter = {
    is?: FloraWhereInput
    isNot?: FloraWhereInput
  }

  export type FloraParqueParqueIdFloraIdCompoundUniqueInput = {
    parqueId: number
    floraId: number
  }

  export type FloraParqueCountOrderByAggregateInput = {
    parqueId?: SortOrder
    floraId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FloraParqueAvgOrderByAggregateInput = {
    parqueId?: SortOrder
    floraId?: SortOrder
  }

  export type FloraParqueMaxOrderByAggregateInput = {
    parqueId?: SortOrder
    floraId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FloraParqueMinOrderByAggregateInput = {
    parqueId?: SortOrder
    floraId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FloraParqueSumOrderByAggregateInput = {
    parqueId?: SortOrder
    floraId?: SortOrder
  }

  export type FaunaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
  }

  export type FaunaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FaunaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
  }

  export type FaunaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    imagen?: SortOrder
    descripcion?: SortOrder
  }

  export type FaunaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FaunaRelationFilter = {
    is?: FaunaWhereInput
    isNot?: FaunaWhereInput
  }

  export type FaunaParqueParqueIdFaunaIDCompoundUniqueInput = {
    parqueId: number
    faunaID: number
  }

  export type FaunaParqueCountOrderByAggregateInput = {
    parqueId?: SortOrder
    faunaID?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FaunaParqueAvgOrderByAggregateInput = {
    parqueId?: SortOrder
    faunaID?: SortOrder
  }

  export type FaunaParqueMaxOrderByAggregateInput = {
    parqueId?: SortOrder
    faunaID?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FaunaParqueMinOrderByAggregateInput = {
    parqueId?: SortOrder
    faunaID?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type FaunaParqueSumOrderByAggregateInput = {
    parqueId?: SortOrder
    faunaID?: SortOrder
  }

  export type ActividadCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type ActividadAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActividadMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type ActividadMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type ActividadSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActividadRelationFilter = {
    is?: ActividadWhereInput
    isNot?: ActividadWhereInput
  }

  export type ActividadParqueParqueIdActividadIdCompoundUniqueInput = {
    parqueId: number
    actividadId: number
  }

  export type ActividadParqueCountOrderByAggregateInput = {
    parqueId?: SortOrder
    actividadId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type ActividadParqueAvgOrderByAggregateInput = {
    parqueId?: SortOrder
    actividadId?: SortOrder
  }

  export type ActividadParqueMaxOrderByAggregateInput = {
    parqueId?: SortOrder
    actividadId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type ActividadParqueMinOrderByAggregateInput = {
    parqueId?: SortOrder
    actividadId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type ActividadParqueSumOrderByAggregateInput = {
    parqueId?: SortOrder
    actividadId?: SortOrder
  }

  export type AnuncioCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    variante?: SortOrder
    parqueId?: SortOrder
  }

  export type AnuncioAvgOrderByAggregateInput = {
    id?: SortOrder
    parqueId?: SortOrder
  }

  export type AnuncioMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    variante?: SortOrder
    parqueId?: SortOrder
  }

  export type AnuncioMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    variante?: SortOrder
    parqueId?: SortOrder
  }

  export type AnuncioSumOrderByAggregateInput = {
    id?: SortOrder
    parqueId?: SortOrder
  }

  export type HorarioCountOrderByAggregateInput = {
    id?: SortOrder
    dias?: SortOrder
    horaAbrir?: SortOrder
    horaCerrar?: SortOrder
    parqueId?: SortOrder
  }

  export type HorarioAvgOrderByAggregateInput = {
    id?: SortOrder
    parqueId?: SortOrder
  }

  export type HorarioMaxOrderByAggregateInput = {
    id?: SortOrder
    dias?: SortOrder
    horaAbrir?: SortOrder
    horaCerrar?: SortOrder
    parqueId?: SortOrder
  }

  export type HorarioMinOrderByAggregateInput = {
    id?: SortOrder
    dias?: SortOrder
    horaAbrir?: SortOrder
    horaCerrar?: SortOrder
    parqueId?: SortOrder
  }

  export type HorarioSumOrderByAggregateInput = {
    id?: SortOrder
    parqueId?: SortOrder
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type AnuncioCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<AnuncioCreateWithoutParqueInput>, Enumerable<AnuncioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<AnuncioCreateOrConnectWithoutParqueInput>
    createMany?: AnuncioCreateManyParqueInputEnvelope
    connect?: Enumerable<AnuncioWhereUniqueInput>
  }

  export type HorarioCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<HorarioCreateWithoutParqueInput>, Enumerable<HorarioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<HorarioCreateOrConnectWithoutParqueInput>
    createMany?: HorarioCreateManyParqueInputEnvelope
    connect?: Enumerable<HorarioWhereUniqueInput>
  }

  export type ActividadParqueCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutParqueInput>, Enumerable<ActividadParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutParqueInput>
    createMany?: ActividadParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
  }

  export type FloraParqueCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutParqueInput>, Enumerable<FloraParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutParqueInput>
    createMany?: FloraParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<FloraParqueWhereUniqueInput>
  }

  export type FaunaParqueCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutParqueInput>, Enumerable<FaunaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutParqueInput>
    createMany?: FaunaParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
  }

  export type CategoriaParqueCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutParqueInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutParqueInput>
    createMany?: CategoriaParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
  }

  export type EstadoParqueCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutParqueInput>, Enumerable<EstadoParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutParqueInput>
    createMany?: EstadoParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
  }

  export type RegionParqueCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutParqueInput>, Enumerable<RegionParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutParqueInput>
    createMany?: RegionParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<RegionParqueWhereUniqueInput>
  }

  export type AnuncioUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<AnuncioCreateWithoutParqueInput>, Enumerable<AnuncioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<AnuncioCreateOrConnectWithoutParqueInput>
    createMany?: AnuncioCreateManyParqueInputEnvelope
    connect?: Enumerable<AnuncioWhereUniqueInput>
  }

  export type HorarioUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<HorarioCreateWithoutParqueInput>, Enumerable<HorarioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<HorarioCreateOrConnectWithoutParqueInput>
    createMany?: HorarioCreateManyParqueInputEnvelope
    connect?: Enumerable<HorarioWhereUniqueInput>
  }

  export type ActividadParqueUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutParqueInput>, Enumerable<ActividadParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutParqueInput>
    createMany?: ActividadParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
  }

  export type FloraParqueUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutParqueInput>, Enumerable<FloraParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutParqueInput>
    createMany?: FloraParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<FloraParqueWhereUniqueInput>
  }

  export type FaunaParqueUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutParqueInput>, Enumerable<FaunaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutParqueInput>
    createMany?: FaunaParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
  }

  export type CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutParqueInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutParqueInput>
    createMany?: CategoriaParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
  }

  export type EstadoParqueUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutParqueInput>, Enumerable<EstadoParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutParqueInput>
    createMany?: EstadoParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
  }

  export type RegionParqueUncheckedCreateNestedManyWithoutParqueInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutParqueInput>, Enumerable<RegionParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutParqueInput>
    createMany?: RegionParqueCreateManyParqueInputEnvelope
    connect?: Enumerable<RegionParqueWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AnuncioUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<AnuncioCreateWithoutParqueInput>, Enumerable<AnuncioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<AnuncioCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<AnuncioUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: AnuncioCreateManyParqueInputEnvelope
    set?: Enumerable<AnuncioWhereUniqueInput>
    disconnect?: Enumerable<AnuncioWhereUniqueInput>
    delete?: Enumerable<AnuncioWhereUniqueInput>
    connect?: Enumerable<AnuncioWhereUniqueInput>
    update?: Enumerable<AnuncioUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<AnuncioUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<AnuncioScalarWhereInput>
  }

  export type HorarioUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<HorarioCreateWithoutParqueInput>, Enumerable<HorarioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<HorarioCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<HorarioUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: HorarioCreateManyParqueInputEnvelope
    set?: Enumerable<HorarioWhereUniqueInput>
    disconnect?: Enumerable<HorarioWhereUniqueInput>
    delete?: Enumerable<HorarioWhereUniqueInput>
    connect?: Enumerable<HorarioWhereUniqueInput>
    update?: Enumerable<HorarioUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<HorarioUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<HorarioScalarWhereInput>
  }

  export type ActividadParqueUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutParqueInput>, Enumerable<ActividadParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<ActividadParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: ActividadParqueCreateManyParqueInputEnvelope
    set?: Enumerable<ActividadParqueWhereUniqueInput>
    disconnect?: Enumerable<ActividadParqueWhereUniqueInput>
    delete?: Enumerable<ActividadParqueWhereUniqueInput>
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
    update?: Enumerable<ActividadParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<ActividadParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<ActividadParqueScalarWhereInput>
  }

  export type FloraParqueUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutParqueInput>, Enumerable<FloraParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<FloraParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: FloraParqueCreateManyParqueInputEnvelope
    set?: Enumerable<FloraParqueWhereUniqueInput>
    disconnect?: Enumerable<FloraParqueWhereUniqueInput>
    delete?: Enumerable<FloraParqueWhereUniqueInput>
    connect?: Enumerable<FloraParqueWhereUniqueInput>
    update?: Enumerable<FloraParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<FloraParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<FloraParqueScalarWhereInput>
  }

  export type FaunaParqueUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutParqueInput>, Enumerable<FaunaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<FaunaParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: FaunaParqueCreateManyParqueInputEnvelope
    set?: Enumerable<FaunaParqueWhereUniqueInput>
    disconnect?: Enumerable<FaunaParqueWhereUniqueInput>
    delete?: Enumerable<FaunaParqueWhereUniqueInput>
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
    update?: Enumerable<FaunaParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<FaunaParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<FaunaParqueScalarWhereInput>
  }

  export type CategoriaParqueUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutParqueInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<CategoriaParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: CategoriaParqueCreateManyParqueInputEnvelope
    set?: Enumerable<CategoriaParqueWhereUniqueInput>
    disconnect?: Enumerable<CategoriaParqueWhereUniqueInput>
    delete?: Enumerable<CategoriaParqueWhereUniqueInput>
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
    update?: Enumerable<CategoriaParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<CategoriaParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<CategoriaParqueScalarWhereInput>
  }

  export type EstadoParqueUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutParqueInput>, Enumerable<EstadoParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<EstadoParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: EstadoParqueCreateManyParqueInputEnvelope
    set?: Enumerable<EstadoParqueWhereUniqueInput>
    disconnect?: Enumerable<EstadoParqueWhereUniqueInput>
    delete?: Enumerable<EstadoParqueWhereUniqueInput>
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
    update?: Enumerable<EstadoParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<EstadoParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<EstadoParqueScalarWhereInput>
  }

  export type RegionParqueUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutParqueInput>, Enumerable<RegionParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<RegionParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: RegionParqueCreateManyParqueInputEnvelope
    set?: Enumerable<RegionParqueWhereUniqueInput>
    disconnect?: Enumerable<RegionParqueWhereUniqueInput>
    delete?: Enumerable<RegionParqueWhereUniqueInput>
    connect?: Enumerable<RegionParqueWhereUniqueInput>
    update?: Enumerable<RegionParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<RegionParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<RegionParqueScalarWhereInput>
  }

  export type AnuncioUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<AnuncioCreateWithoutParqueInput>, Enumerable<AnuncioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<AnuncioCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<AnuncioUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: AnuncioCreateManyParqueInputEnvelope
    set?: Enumerable<AnuncioWhereUniqueInput>
    disconnect?: Enumerable<AnuncioWhereUniqueInput>
    delete?: Enumerable<AnuncioWhereUniqueInput>
    connect?: Enumerable<AnuncioWhereUniqueInput>
    update?: Enumerable<AnuncioUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<AnuncioUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<AnuncioScalarWhereInput>
  }

  export type HorarioUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<HorarioCreateWithoutParqueInput>, Enumerable<HorarioUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<HorarioCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<HorarioUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: HorarioCreateManyParqueInputEnvelope
    set?: Enumerable<HorarioWhereUniqueInput>
    disconnect?: Enumerable<HorarioWhereUniqueInput>
    delete?: Enumerable<HorarioWhereUniqueInput>
    connect?: Enumerable<HorarioWhereUniqueInput>
    update?: Enumerable<HorarioUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<HorarioUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<HorarioScalarWhereInput>
  }

  export type ActividadParqueUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutParqueInput>, Enumerable<ActividadParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<ActividadParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: ActividadParqueCreateManyParqueInputEnvelope
    set?: Enumerable<ActividadParqueWhereUniqueInput>
    disconnect?: Enumerable<ActividadParqueWhereUniqueInput>
    delete?: Enumerable<ActividadParqueWhereUniqueInput>
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
    update?: Enumerable<ActividadParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<ActividadParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<ActividadParqueScalarWhereInput>
  }

  export type FloraParqueUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutParqueInput>, Enumerable<FloraParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<FloraParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: FloraParqueCreateManyParqueInputEnvelope
    set?: Enumerable<FloraParqueWhereUniqueInput>
    disconnect?: Enumerable<FloraParqueWhereUniqueInput>
    delete?: Enumerable<FloraParqueWhereUniqueInput>
    connect?: Enumerable<FloraParqueWhereUniqueInput>
    update?: Enumerable<FloraParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<FloraParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<FloraParqueScalarWhereInput>
  }

  export type FaunaParqueUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutParqueInput>, Enumerable<FaunaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<FaunaParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: FaunaParqueCreateManyParqueInputEnvelope
    set?: Enumerable<FaunaParqueWhereUniqueInput>
    disconnect?: Enumerable<FaunaParqueWhereUniqueInput>
    delete?: Enumerable<FaunaParqueWhereUniqueInput>
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
    update?: Enumerable<FaunaParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<FaunaParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<FaunaParqueScalarWhereInput>
  }

  export type CategoriaParqueUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutParqueInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<CategoriaParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: CategoriaParqueCreateManyParqueInputEnvelope
    set?: Enumerable<CategoriaParqueWhereUniqueInput>
    disconnect?: Enumerable<CategoriaParqueWhereUniqueInput>
    delete?: Enumerable<CategoriaParqueWhereUniqueInput>
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
    update?: Enumerable<CategoriaParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<CategoriaParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<CategoriaParqueScalarWhereInput>
  }

  export type EstadoParqueUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutParqueInput>, Enumerable<EstadoParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<EstadoParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: EstadoParqueCreateManyParqueInputEnvelope
    set?: Enumerable<EstadoParqueWhereUniqueInput>
    disconnect?: Enumerable<EstadoParqueWhereUniqueInput>
    delete?: Enumerable<EstadoParqueWhereUniqueInput>
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
    update?: Enumerable<EstadoParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<EstadoParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<EstadoParqueScalarWhereInput>
  }

  export type RegionParqueUncheckedUpdateManyWithoutParqueInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutParqueInput>, Enumerable<RegionParqueUncheckedCreateWithoutParqueInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutParqueInput>
    upsert?: Enumerable<RegionParqueUpsertWithWhereUniqueWithoutParqueInput>
    createMany?: RegionParqueCreateManyParqueInputEnvelope
    set?: Enumerable<RegionParqueWhereUniqueInput>
    disconnect?: Enumerable<RegionParqueWhereUniqueInput>
    delete?: Enumerable<RegionParqueWhereUniqueInput>
    connect?: Enumerable<RegionParqueWhereUniqueInput>
    update?: Enumerable<RegionParqueUpdateWithWhereUniqueWithoutParqueInput>
    updateMany?: Enumerable<RegionParqueUpdateManyWithWhereWithoutParqueInput>
    deleteMany?: Enumerable<RegionParqueScalarWhereInput>
  }

  export type EstadoParqueCreateNestedManyWithoutEstadoInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutEstadoInput>, Enumerable<EstadoParqueUncheckedCreateWithoutEstadoInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutEstadoInput>
    createMany?: EstadoParqueCreateManyEstadoInputEnvelope
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
  }

  export type EstadoParqueUncheckedCreateNestedManyWithoutEstadoInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutEstadoInput>, Enumerable<EstadoParqueUncheckedCreateWithoutEstadoInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutEstadoInput>
    createMany?: EstadoParqueCreateManyEstadoInputEnvelope
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
  }

  export type EstadoParqueUpdateManyWithoutEstadoInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutEstadoInput>, Enumerable<EstadoParqueUncheckedCreateWithoutEstadoInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutEstadoInput>
    upsert?: Enumerable<EstadoParqueUpsertWithWhereUniqueWithoutEstadoInput>
    createMany?: EstadoParqueCreateManyEstadoInputEnvelope
    set?: Enumerable<EstadoParqueWhereUniqueInput>
    disconnect?: Enumerable<EstadoParqueWhereUniqueInput>
    delete?: Enumerable<EstadoParqueWhereUniqueInput>
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
    update?: Enumerable<EstadoParqueUpdateWithWhereUniqueWithoutEstadoInput>
    updateMany?: Enumerable<EstadoParqueUpdateManyWithWhereWithoutEstadoInput>
    deleteMany?: Enumerable<EstadoParqueScalarWhereInput>
  }

  export type EstadoParqueUncheckedUpdateManyWithoutEstadoInput = {
    create?: XOR<Enumerable<EstadoParqueCreateWithoutEstadoInput>, Enumerable<EstadoParqueUncheckedCreateWithoutEstadoInput>>
    connectOrCreate?: Enumerable<EstadoParqueCreateOrConnectWithoutEstadoInput>
    upsert?: Enumerable<EstadoParqueUpsertWithWhereUniqueWithoutEstadoInput>
    createMany?: EstadoParqueCreateManyEstadoInputEnvelope
    set?: Enumerable<EstadoParqueWhereUniqueInput>
    disconnect?: Enumerable<EstadoParqueWhereUniqueInput>
    delete?: Enumerable<EstadoParqueWhereUniqueInput>
    connect?: Enumerable<EstadoParqueWhereUniqueInput>
    update?: Enumerable<EstadoParqueUpdateWithWhereUniqueWithoutEstadoInput>
    updateMany?: Enumerable<EstadoParqueUpdateManyWithWhereWithoutEstadoInput>
    deleteMany?: Enumerable<EstadoParqueScalarWhereInput>
  }

  export type ParqueCreateNestedOneWithoutEstadoInput = {
    create?: XOR<ParqueCreateWithoutEstadoInput, ParqueUncheckedCreateWithoutEstadoInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutEstadoInput
    connect?: ParqueWhereUniqueInput
  }

  export type EstadoCreateNestedOneWithoutParqueInput = {
    create?: XOR<EstadoCreateWithoutParqueInput, EstadoUncheckedCreateWithoutParqueInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutParqueInput
    connect?: EstadoWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutEstadoInput = {
    create?: XOR<ParqueCreateWithoutEstadoInput, ParqueUncheckedCreateWithoutEstadoInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutEstadoInput
    upsert?: ParqueUpsertWithoutEstadoInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutEstadoInput, ParqueUncheckedUpdateWithoutEstadoInput>
  }

  export type EstadoUpdateOneRequiredWithoutParqueInput = {
    create?: XOR<EstadoCreateWithoutParqueInput, EstadoUncheckedCreateWithoutParqueInput>
    connectOrCreate?: EstadoCreateOrConnectWithoutParqueInput
    upsert?: EstadoUpsertWithoutParqueInput
    connect?: EstadoWhereUniqueInput
    update?: XOR<EstadoUpdateWithoutParqueInput, EstadoUncheckedUpdateWithoutParqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RegionParqueCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutRegionInput>, Enumerable<RegionParqueUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutRegionInput>
    createMany?: RegionParqueCreateManyRegionInputEnvelope
    connect?: Enumerable<RegionParqueWhereUniqueInput>
  }

  export type RegionParqueUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutRegionInput>, Enumerable<RegionParqueUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutRegionInput>
    createMany?: RegionParqueCreateManyRegionInputEnvelope
    connect?: Enumerable<RegionParqueWhereUniqueInput>
  }

  export type RegionParqueUpdateManyWithoutRegionInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutRegionInput>, Enumerable<RegionParqueUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<RegionParqueUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: RegionParqueCreateManyRegionInputEnvelope
    set?: Enumerable<RegionParqueWhereUniqueInput>
    disconnect?: Enumerable<RegionParqueWhereUniqueInput>
    delete?: Enumerable<RegionParqueWhereUniqueInput>
    connect?: Enumerable<RegionParqueWhereUniqueInput>
    update?: Enumerable<RegionParqueUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<RegionParqueUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<RegionParqueScalarWhereInput>
  }

  export type RegionParqueUncheckedUpdateManyWithoutRegionInput = {
    create?: XOR<Enumerable<RegionParqueCreateWithoutRegionInput>, Enumerable<RegionParqueUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<RegionParqueCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<RegionParqueUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: RegionParqueCreateManyRegionInputEnvelope
    set?: Enumerable<RegionParqueWhereUniqueInput>
    disconnect?: Enumerable<RegionParqueWhereUniqueInput>
    delete?: Enumerable<RegionParqueWhereUniqueInput>
    connect?: Enumerable<RegionParqueWhereUniqueInput>
    update?: Enumerable<RegionParqueUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<RegionParqueUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<RegionParqueScalarWhereInput>
  }

  export type ParqueCreateNestedOneWithoutRegionInput = {
    create?: XOR<ParqueCreateWithoutRegionInput, ParqueUncheckedCreateWithoutRegionInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutRegionInput
    connect?: ParqueWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutParqueInput = {
    create?: XOR<RegionCreateWithoutParqueInput, RegionUncheckedCreateWithoutParqueInput>
    connectOrCreate?: RegionCreateOrConnectWithoutParqueInput
    connect?: RegionWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutRegionInput = {
    create?: XOR<ParqueCreateWithoutRegionInput, ParqueUncheckedCreateWithoutRegionInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutRegionInput
    upsert?: ParqueUpsertWithoutRegionInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutRegionInput, ParqueUncheckedUpdateWithoutRegionInput>
  }

  export type RegionUpdateOneRequiredWithoutParqueInput = {
    create?: XOR<RegionCreateWithoutParqueInput, RegionUncheckedCreateWithoutParqueInput>
    connectOrCreate?: RegionCreateOrConnectWithoutParqueInput
    upsert?: RegionUpsertWithoutParqueInput
    connect?: RegionWhereUniqueInput
    update?: XOR<RegionUpdateWithoutParqueInput, RegionUncheckedUpdateWithoutParqueInput>
  }

  export type CategoriaParqueCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutCategoriaInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutCategoriaInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutCategoriaInput>
    createMany?: CategoriaParqueCreateManyCategoriaInputEnvelope
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
  }

  export type CategoriaParqueUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutCategoriaInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutCategoriaInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutCategoriaInput>
    createMany?: CategoriaParqueCreateManyCategoriaInputEnvelope
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
  }

  export type CategoriaParqueUpdateManyWithoutCategoriaInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutCategoriaInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutCategoriaInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutCategoriaInput>
    upsert?: Enumerable<CategoriaParqueUpsertWithWhereUniqueWithoutCategoriaInput>
    createMany?: CategoriaParqueCreateManyCategoriaInputEnvelope
    set?: Enumerable<CategoriaParqueWhereUniqueInput>
    disconnect?: Enumerable<CategoriaParqueWhereUniqueInput>
    delete?: Enumerable<CategoriaParqueWhereUniqueInput>
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
    update?: Enumerable<CategoriaParqueUpdateWithWhereUniqueWithoutCategoriaInput>
    updateMany?: Enumerable<CategoriaParqueUpdateManyWithWhereWithoutCategoriaInput>
    deleteMany?: Enumerable<CategoriaParqueScalarWhereInput>
  }

  export type CategoriaParqueUncheckedUpdateManyWithoutCategoriaInput = {
    create?: XOR<Enumerable<CategoriaParqueCreateWithoutCategoriaInput>, Enumerable<CategoriaParqueUncheckedCreateWithoutCategoriaInput>>
    connectOrCreate?: Enumerable<CategoriaParqueCreateOrConnectWithoutCategoriaInput>
    upsert?: Enumerable<CategoriaParqueUpsertWithWhereUniqueWithoutCategoriaInput>
    createMany?: CategoriaParqueCreateManyCategoriaInputEnvelope
    set?: Enumerable<CategoriaParqueWhereUniqueInput>
    disconnect?: Enumerable<CategoriaParqueWhereUniqueInput>
    delete?: Enumerable<CategoriaParqueWhereUniqueInput>
    connect?: Enumerable<CategoriaParqueWhereUniqueInput>
    update?: Enumerable<CategoriaParqueUpdateWithWhereUniqueWithoutCategoriaInput>
    updateMany?: Enumerable<CategoriaParqueUpdateManyWithWhereWithoutCategoriaInput>
    deleteMany?: Enumerable<CategoriaParqueScalarWhereInput>
  }

  export type ParqueCreateNestedOneWithoutCategoriaInput = {
    create?: XOR<ParqueCreateWithoutCategoriaInput, ParqueUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutCategoriaInput
    connect?: ParqueWhereUniqueInput
  }

  export type CategoriaCreateNestedOneWithoutParqueInput = {
    create?: XOR<CategoriaCreateWithoutParqueInput, CategoriaUncheckedCreateWithoutParqueInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutParqueInput
    connect?: CategoriaWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutCategoriaInput = {
    create?: XOR<ParqueCreateWithoutCategoriaInput, ParqueUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutCategoriaInput
    upsert?: ParqueUpsertWithoutCategoriaInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutCategoriaInput, ParqueUncheckedUpdateWithoutCategoriaInput>
  }

  export type CategoriaUpdateOneRequiredWithoutParqueInput = {
    create?: XOR<CategoriaCreateWithoutParqueInput, CategoriaUncheckedCreateWithoutParqueInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutParqueInput
    upsert?: CategoriaUpsertWithoutParqueInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<CategoriaUpdateWithoutParqueInput, CategoriaUncheckedUpdateWithoutParqueInput>
  }

  export type FloraParqueCreateNestedManyWithoutFloraInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutFloraInput>, Enumerable<FloraParqueUncheckedCreateWithoutFloraInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutFloraInput>
    createMany?: FloraParqueCreateManyFloraInputEnvelope
    connect?: Enumerable<FloraParqueWhereUniqueInput>
  }

  export type FloraParqueUncheckedCreateNestedManyWithoutFloraInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutFloraInput>, Enumerable<FloraParqueUncheckedCreateWithoutFloraInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutFloraInput>
    createMany?: FloraParqueCreateManyFloraInputEnvelope
    connect?: Enumerable<FloraParqueWhereUniqueInput>
  }

  export type FloraParqueUpdateManyWithoutFloraInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutFloraInput>, Enumerable<FloraParqueUncheckedCreateWithoutFloraInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutFloraInput>
    upsert?: Enumerable<FloraParqueUpsertWithWhereUniqueWithoutFloraInput>
    createMany?: FloraParqueCreateManyFloraInputEnvelope
    set?: Enumerable<FloraParqueWhereUniqueInput>
    disconnect?: Enumerable<FloraParqueWhereUniqueInput>
    delete?: Enumerable<FloraParqueWhereUniqueInput>
    connect?: Enumerable<FloraParqueWhereUniqueInput>
    update?: Enumerable<FloraParqueUpdateWithWhereUniqueWithoutFloraInput>
    updateMany?: Enumerable<FloraParqueUpdateManyWithWhereWithoutFloraInput>
    deleteMany?: Enumerable<FloraParqueScalarWhereInput>
  }

  export type FloraParqueUncheckedUpdateManyWithoutFloraInput = {
    create?: XOR<Enumerable<FloraParqueCreateWithoutFloraInput>, Enumerable<FloraParqueUncheckedCreateWithoutFloraInput>>
    connectOrCreate?: Enumerable<FloraParqueCreateOrConnectWithoutFloraInput>
    upsert?: Enumerable<FloraParqueUpsertWithWhereUniqueWithoutFloraInput>
    createMany?: FloraParqueCreateManyFloraInputEnvelope
    set?: Enumerable<FloraParqueWhereUniqueInput>
    disconnect?: Enumerable<FloraParqueWhereUniqueInput>
    delete?: Enumerable<FloraParqueWhereUniqueInput>
    connect?: Enumerable<FloraParqueWhereUniqueInput>
    update?: Enumerable<FloraParqueUpdateWithWhereUniqueWithoutFloraInput>
    updateMany?: Enumerable<FloraParqueUpdateManyWithWhereWithoutFloraInput>
    deleteMany?: Enumerable<FloraParqueScalarWhereInput>
  }

  export type ParqueCreateNestedOneWithoutFloraInput = {
    create?: XOR<ParqueCreateWithoutFloraInput, ParqueUncheckedCreateWithoutFloraInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutFloraInput
    connect?: ParqueWhereUniqueInput
  }

  export type FloraCreateNestedOneWithoutParquesInput = {
    create?: XOR<FloraCreateWithoutParquesInput, FloraUncheckedCreateWithoutParquesInput>
    connectOrCreate?: FloraCreateOrConnectWithoutParquesInput
    connect?: FloraWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutFloraInput = {
    create?: XOR<ParqueCreateWithoutFloraInput, ParqueUncheckedCreateWithoutFloraInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutFloraInput
    upsert?: ParqueUpsertWithoutFloraInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutFloraInput, ParqueUncheckedUpdateWithoutFloraInput>
  }

  export type FloraUpdateOneRequiredWithoutParquesInput = {
    create?: XOR<FloraCreateWithoutParquesInput, FloraUncheckedCreateWithoutParquesInput>
    connectOrCreate?: FloraCreateOrConnectWithoutParquesInput
    upsert?: FloraUpsertWithoutParquesInput
    connect?: FloraWhereUniqueInput
    update?: XOR<FloraUpdateWithoutParquesInput, FloraUncheckedUpdateWithoutParquesInput>
  }

  export type FaunaParqueCreateNestedManyWithoutFaunaInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutFaunaInput>, Enumerable<FaunaParqueUncheckedCreateWithoutFaunaInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutFaunaInput>
    createMany?: FaunaParqueCreateManyFaunaInputEnvelope
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
  }

  export type FaunaParqueUncheckedCreateNestedManyWithoutFaunaInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutFaunaInput>, Enumerable<FaunaParqueUncheckedCreateWithoutFaunaInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutFaunaInput>
    createMany?: FaunaParqueCreateManyFaunaInputEnvelope
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
  }

  export type FaunaParqueUpdateManyWithoutFaunaInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutFaunaInput>, Enumerable<FaunaParqueUncheckedCreateWithoutFaunaInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutFaunaInput>
    upsert?: Enumerable<FaunaParqueUpsertWithWhereUniqueWithoutFaunaInput>
    createMany?: FaunaParqueCreateManyFaunaInputEnvelope
    set?: Enumerable<FaunaParqueWhereUniqueInput>
    disconnect?: Enumerable<FaunaParqueWhereUniqueInput>
    delete?: Enumerable<FaunaParqueWhereUniqueInput>
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
    update?: Enumerable<FaunaParqueUpdateWithWhereUniqueWithoutFaunaInput>
    updateMany?: Enumerable<FaunaParqueUpdateManyWithWhereWithoutFaunaInput>
    deleteMany?: Enumerable<FaunaParqueScalarWhereInput>
  }

  export type FaunaParqueUncheckedUpdateManyWithoutFaunaInput = {
    create?: XOR<Enumerable<FaunaParqueCreateWithoutFaunaInput>, Enumerable<FaunaParqueUncheckedCreateWithoutFaunaInput>>
    connectOrCreate?: Enumerable<FaunaParqueCreateOrConnectWithoutFaunaInput>
    upsert?: Enumerable<FaunaParqueUpsertWithWhereUniqueWithoutFaunaInput>
    createMany?: FaunaParqueCreateManyFaunaInputEnvelope
    set?: Enumerable<FaunaParqueWhereUniqueInput>
    disconnect?: Enumerable<FaunaParqueWhereUniqueInput>
    delete?: Enumerable<FaunaParqueWhereUniqueInput>
    connect?: Enumerable<FaunaParqueWhereUniqueInput>
    update?: Enumerable<FaunaParqueUpdateWithWhereUniqueWithoutFaunaInput>
    updateMany?: Enumerable<FaunaParqueUpdateManyWithWhereWithoutFaunaInput>
    deleteMany?: Enumerable<FaunaParqueScalarWhereInput>
  }

  export type ParqueCreateNestedOneWithoutFaunaInput = {
    create?: XOR<ParqueCreateWithoutFaunaInput, ParqueUncheckedCreateWithoutFaunaInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutFaunaInput
    connect?: ParqueWhereUniqueInput
  }

  export type FaunaCreateNestedOneWithoutParquesInput = {
    create?: XOR<FaunaCreateWithoutParquesInput, FaunaUncheckedCreateWithoutParquesInput>
    connectOrCreate?: FaunaCreateOrConnectWithoutParquesInput
    connect?: FaunaWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutFaunaInput = {
    create?: XOR<ParqueCreateWithoutFaunaInput, ParqueUncheckedCreateWithoutFaunaInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutFaunaInput
    upsert?: ParqueUpsertWithoutFaunaInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutFaunaInput, ParqueUncheckedUpdateWithoutFaunaInput>
  }

  export type FaunaUpdateOneRequiredWithoutParquesInput = {
    create?: XOR<FaunaCreateWithoutParquesInput, FaunaUncheckedCreateWithoutParquesInput>
    connectOrCreate?: FaunaCreateOrConnectWithoutParquesInput
    upsert?: FaunaUpsertWithoutParquesInput
    connect?: FaunaWhereUniqueInput
    update?: XOR<FaunaUpdateWithoutParquesInput, FaunaUncheckedUpdateWithoutParquesInput>
  }

  export type ActividadParqueCreateNestedManyWithoutActividadInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutActividadInput>, Enumerable<ActividadParqueUncheckedCreateWithoutActividadInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutActividadInput>
    createMany?: ActividadParqueCreateManyActividadInputEnvelope
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
  }

  export type ActividadParqueUncheckedCreateNestedManyWithoutActividadInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutActividadInput>, Enumerable<ActividadParqueUncheckedCreateWithoutActividadInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutActividadInput>
    createMany?: ActividadParqueCreateManyActividadInputEnvelope
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
  }

  export type ActividadParqueUpdateManyWithoutActividadInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutActividadInput>, Enumerable<ActividadParqueUncheckedCreateWithoutActividadInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutActividadInput>
    upsert?: Enumerable<ActividadParqueUpsertWithWhereUniqueWithoutActividadInput>
    createMany?: ActividadParqueCreateManyActividadInputEnvelope
    set?: Enumerable<ActividadParqueWhereUniqueInput>
    disconnect?: Enumerable<ActividadParqueWhereUniqueInput>
    delete?: Enumerable<ActividadParqueWhereUniqueInput>
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
    update?: Enumerable<ActividadParqueUpdateWithWhereUniqueWithoutActividadInput>
    updateMany?: Enumerable<ActividadParqueUpdateManyWithWhereWithoutActividadInput>
    deleteMany?: Enumerable<ActividadParqueScalarWhereInput>
  }

  export type ActividadParqueUncheckedUpdateManyWithoutActividadInput = {
    create?: XOR<Enumerable<ActividadParqueCreateWithoutActividadInput>, Enumerable<ActividadParqueUncheckedCreateWithoutActividadInput>>
    connectOrCreate?: Enumerable<ActividadParqueCreateOrConnectWithoutActividadInput>
    upsert?: Enumerable<ActividadParqueUpsertWithWhereUniqueWithoutActividadInput>
    createMany?: ActividadParqueCreateManyActividadInputEnvelope
    set?: Enumerable<ActividadParqueWhereUniqueInput>
    disconnect?: Enumerable<ActividadParqueWhereUniqueInput>
    delete?: Enumerable<ActividadParqueWhereUniqueInput>
    connect?: Enumerable<ActividadParqueWhereUniqueInput>
    update?: Enumerable<ActividadParqueUpdateWithWhereUniqueWithoutActividadInput>
    updateMany?: Enumerable<ActividadParqueUpdateManyWithWhereWithoutActividadInput>
    deleteMany?: Enumerable<ActividadParqueScalarWhereInput>
  }

  export type ParqueCreateNestedOneWithoutActividadesInput = {
    create?: XOR<ParqueCreateWithoutActividadesInput, ParqueUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutActividadesInput
    connect?: ParqueWhereUniqueInput
  }

  export type ActividadCreateNestedOneWithoutParquesInput = {
    create?: XOR<ActividadCreateWithoutParquesInput, ActividadUncheckedCreateWithoutParquesInput>
    connectOrCreate?: ActividadCreateOrConnectWithoutParquesInput
    connect?: ActividadWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutActividadesInput = {
    create?: XOR<ParqueCreateWithoutActividadesInput, ParqueUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutActividadesInput
    upsert?: ParqueUpsertWithoutActividadesInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutActividadesInput, ParqueUncheckedUpdateWithoutActividadesInput>
  }

  export type ActividadUpdateOneRequiredWithoutParquesInput = {
    create?: XOR<ActividadCreateWithoutParquesInput, ActividadUncheckedCreateWithoutParquesInput>
    connectOrCreate?: ActividadCreateOrConnectWithoutParquesInput
    upsert?: ActividadUpsertWithoutParquesInput
    connect?: ActividadWhereUniqueInput
    update?: XOR<ActividadUpdateWithoutParquesInput, ActividadUncheckedUpdateWithoutParquesInput>
  }

  export type ParqueCreateNestedOneWithoutAnunciosInput = {
    create?: XOR<ParqueCreateWithoutAnunciosInput, ParqueUncheckedCreateWithoutAnunciosInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutAnunciosInput
    connect?: ParqueWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutAnunciosInput = {
    create?: XOR<ParqueCreateWithoutAnunciosInput, ParqueUncheckedCreateWithoutAnunciosInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutAnunciosInput
    upsert?: ParqueUpsertWithoutAnunciosInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutAnunciosInput, ParqueUncheckedUpdateWithoutAnunciosInput>
  }

  export type ParqueCreateNestedOneWithoutHorarioInput = {
    create?: XOR<ParqueCreateWithoutHorarioInput, ParqueUncheckedCreateWithoutHorarioInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutHorarioInput
    connect?: ParqueWhereUniqueInput
  }

  export type ParqueUpdateOneRequiredWithoutHorarioInput = {
    create?: XOR<ParqueCreateWithoutHorarioInput, ParqueUncheckedCreateWithoutHorarioInput>
    connectOrCreate?: ParqueCreateOrConnectWithoutHorarioInput
    upsert?: ParqueUpsertWithoutHorarioInput
    connect?: ParqueWhereUniqueInput
    update?: XOR<ParqueUpdateWithoutHorarioInput, ParqueUncheckedUpdateWithoutHorarioInput>
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type AnuncioCreateWithoutParqueInput = {
    titulo: string
    descripcion: string
    variante: string
  }

  export type AnuncioUncheckedCreateWithoutParqueInput = {
    id?: number
    titulo: string
    descripcion: string
    variante: string
  }

  export type AnuncioCreateOrConnectWithoutParqueInput = {
    where: AnuncioWhereUniqueInput
    create: XOR<AnuncioCreateWithoutParqueInput, AnuncioUncheckedCreateWithoutParqueInput>
  }

  export type AnuncioCreateManyParqueInputEnvelope = {
    data: Enumerable<AnuncioCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type HorarioCreateWithoutParqueInput = {
    dias: string
    horaAbrir: string
    horaCerrar: string
  }

  export type HorarioUncheckedCreateWithoutParqueInput = {
    id?: number
    dias: string
    horaAbrir: string
    horaCerrar: string
  }

  export type HorarioCreateOrConnectWithoutParqueInput = {
    where: HorarioWhereUniqueInput
    create: XOR<HorarioCreateWithoutParqueInput, HorarioUncheckedCreateWithoutParqueInput>
  }

  export type HorarioCreateManyParqueInputEnvelope = {
    data: Enumerable<HorarioCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type ActividadParqueCreateWithoutParqueInput = {
    actividad: ActividadCreateNestedOneWithoutParquesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueUncheckedCreateWithoutParqueInput = {
    actividadId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueCreateOrConnectWithoutParqueInput = {
    where: ActividadParqueWhereUniqueInput
    create: XOR<ActividadParqueCreateWithoutParqueInput, ActividadParqueUncheckedCreateWithoutParqueInput>
  }

  export type ActividadParqueCreateManyParqueInputEnvelope = {
    data: Enumerable<ActividadParqueCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type FloraParqueCreateWithoutParqueInput = {
    flora: FloraCreateNestedOneWithoutParquesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueUncheckedCreateWithoutParqueInput = {
    floraId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueCreateOrConnectWithoutParqueInput = {
    where: FloraParqueWhereUniqueInput
    create: XOR<FloraParqueCreateWithoutParqueInput, FloraParqueUncheckedCreateWithoutParqueInput>
  }

  export type FloraParqueCreateManyParqueInputEnvelope = {
    data: Enumerable<FloraParqueCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type FaunaParqueCreateWithoutParqueInput = {
    fauna: FaunaCreateNestedOneWithoutParquesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueUncheckedCreateWithoutParqueInput = {
    faunaID: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueCreateOrConnectWithoutParqueInput = {
    where: FaunaParqueWhereUniqueInput
    create: XOR<FaunaParqueCreateWithoutParqueInput, FaunaParqueUncheckedCreateWithoutParqueInput>
  }

  export type FaunaParqueCreateManyParqueInputEnvelope = {
    data: Enumerable<FaunaParqueCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type CategoriaParqueCreateWithoutParqueInput = {
    categoria: CategoriaCreateNestedOneWithoutParqueInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueUncheckedCreateWithoutParqueInput = {
    categoriaId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueCreateOrConnectWithoutParqueInput = {
    where: CategoriaParqueWhereUniqueInput
    create: XOR<CategoriaParqueCreateWithoutParqueInput, CategoriaParqueUncheckedCreateWithoutParqueInput>
  }

  export type CategoriaParqueCreateManyParqueInputEnvelope = {
    data: Enumerable<CategoriaParqueCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type EstadoParqueCreateWithoutParqueInput = {
    estado: EstadoCreateNestedOneWithoutParqueInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueUncheckedCreateWithoutParqueInput = {
    estadoId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueCreateOrConnectWithoutParqueInput = {
    where: EstadoParqueWhereUniqueInput
    create: XOR<EstadoParqueCreateWithoutParqueInput, EstadoParqueUncheckedCreateWithoutParqueInput>
  }

  export type EstadoParqueCreateManyParqueInputEnvelope = {
    data: Enumerable<EstadoParqueCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type RegionParqueCreateWithoutParqueInput = {
    region: RegionCreateNestedOneWithoutParqueInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueUncheckedCreateWithoutParqueInput = {
    regionId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueCreateOrConnectWithoutParqueInput = {
    where: RegionParqueWhereUniqueInput
    create: XOR<RegionParqueCreateWithoutParqueInput, RegionParqueUncheckedCreateWithoutParqueInput>
  }

  export type RegionParqueCreateManyParqueInputEnvelope = {
    data: Enumerable<RegionParqueCreateManyParqueInput>
    skipDuplicates?: boolean
  }

  export type AnuncioUpsertWithWhereUniqueWithoutParqueInput = {
    where: AnuncioWhereUniqueInput
    update: XOR<AnuncioUpdateWithoutParqueInput, AnuncioUncheckedUpdateWithoutParqueInput>
    create: XOR<AnuncioCreateWithoutParqueInput, AnuncioUncheckedCreateWithoutParqueInput>
  }

  export type AnuncioUpdateWithWhereUniqueWithoutParqueInput = {
    where: AnuncioWhereUniqueInput
    data: XOR<AnuncioUpdateWithoutParqueInput, AnuncioUncheckedUpdateWithoutParqueInput>
  }

  export type AnuncioUpdateManyWithWhereWithoutParqueInput = {
    where: AnuncioScalarWhereInput
    data: XOR<AnuncioUpdateManyMutationInput, AnuncioUncheckedUpdateManyWithoutAnunciosInput>
  }

  export type AnuncioScalarWhereInput = {
    AND?: Enumerable<AnuncioScalarWhereInput>
    OR?: Enumerable<AnuncioScalarWhereInput>
    NOT?: Enumerable<AnuncioScalarWhereInput>
    id?: IntFilter | number
    titulo?: StringFilter | string
    descripcion?: StringFilter | string
    variante?: StringFilter | string
    parqueId?: IntFilter | number
  }

  export type HorarioUpsertWithWhereUniqueWithoutParqueInput = {
    where: HorarioWhereUniqueInput
    update: XOR<HorarioUpdateWithoutParqueInput, HorarioUncheckedUpdateWithoutParqueInput>
    create: XOR<HorarioCreateWithoutParqueInput, HorarioUncheckedCreateWithoutParqueInput>
  }

  export type HorarioUpdateWithWhereUniqueWithoutParqueInput = {
    where: HorarioWhereUniqueInput
    data: XOR<HorarioUpdateWithoutParqueInput, HorarioUncheckedUpdateWithoutParqueInput>
  }

  export type HorarioUpdateManyWithWhereWithoutParqueInput = {
    where: HorarioScalarWhereInput
    data: XOR<HorarioUpdateManyMutationInput, HorarioUncheckedUpdateManyWithoutHorarioInput>
  }

  export type HorarioScalarWhereInput = {
    AND?: Enumerable<HorarioScalarWhereInput>
    OR?: Enumerable<HorarioScalarWhereInput>
    NOT?: Enumerable<HorarioScalarWhereInput>
    id?: IntFilter | number
    dias?: StringFilter | string
    horaAbrir?: StringFilter | string
    horaCerrar?: StringFilter | string
    parqueId?: IntFilter | number
  }

  export type ActividadParqueUpsertWithWhereUniqueWithoutParqueInput = {
    where: ActividadParqueWhereUniqueInput
    update: XOR<ActividadParqueUpdateWithoutParqueInput, ActividadParqueUncheckedUpdateWithoutParqueInput>
    create: XOR<ActividadParqueCreateWithoutParqueInput, ActividadParqueUncheckedCreateWithoutParqueInput>
  }

  export type ActividadParqueUpdateWithWhereUniqueWithoutParqueInput = {
    where: ActividadParqueWhereUniqueInput
    data: XOR<ActividadParqueUpdateWithoutParqueInput, ActividadParqueUncheckedUpdateWithoutParqueInput>
  }

  export type ActividadParqueUpdateManyWithWhereWithoutParqueInput = {
    where: ActividadParqueScalarWhereInput
    data: XOR<ActividadParqueUpdateManyMutationInput, ActividadParqueUncheckedUpdateManyWithoutActividadesInput>
  }

  export type ActividadParqueScalarWhereInput = {
    AND?: Enumerable<ActividadParqueScalarWhereInput>
    OR?: Enumerable<ActividadParqueScalarWhereInput>
    NOT?: Enumerable<ActividadParqueScalarWhereInput>
    parqueId?: IntFilter | number
    actividadId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type FloraParqueUpsertWithWhereUniqueWithoutParqueInput = {
    where: FloraParqueWhereUniqueInput
    update: XOR<FloraParqueUpdateWithoutParqueInput, FloraParqueUncheckedUpdateWithoutParqueInput>
    create: XOR<FloraParqueCreateWithoutParqueInput, FloraParqueUncheckedCreateWithoutParqueInput>
  }

  export type FloraParqueUpdateWithWhereUniqueWithoutParqueInput = {
    where: FloraParqueWhereUniqueInput
    data: XOR<FloraParqueUpdateWithoutParqueInput, FloraParqueUncheckedUpdateWithoutParqueInput>
  }

  export type FloraParqueUpdateManyWithWhereWithoutParqueInput = {
    where: FloraParqueScalarWhereInput
    data: XOR<FloraParqueUpdateManyMutationInput, FloraParqueUncheckedUpdateManyWithoutFloraInput>
  }

  export type FloraParqueScalarWhereInput = {
    AND?: Enumerable<FloraParqueScalarWhereInput>
    OR?: Enumerable<FloraParqueScalarWhereInput>
    NOT?: Enumerable<FloraParqueScalarWhereInput>
    parqueId?: IntFilter | number
    floraId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type FaunaParqueUpsertWithWhereUniqueWithoutParqueInput = {
    where: FaunaParqueWhereUniqueInput
    update: XOR<FaunaParqueUpdateWithoutParqueInput, FaunaParqueUncheckedUpdateWithoutParqueInput>
    create: XOR<FaunaParqueCreateWithoutParqueInput, FaunaParqueUncheckedCreateWithoutParqueInput>
  }

  export type FaunaParqueUpdateWithWhereUniqueWithoutParqueInput = {
    where: FaunaParqueWhereUniqueInput
    data: XOR<FaunaParqueUpdateWithoutParqueInput, FaunaParqueUncheckedUpdateWithoutParqueInput>
  }

  export type FaunaParqueUpdateManyWithWhereWithoutParqueInput = {
    where: FaunaParqueScalarWhereInput
    data: XOR<FaunaParqueUpdateManyMutationInput, FaunaParqueUncheckedUpdateManyWithoutFaunaInput>
  }

  export type FaunaParqueScalarWhereInput = {
    AND?: Enumerable<FaunaParqueScalarWhereInput>
    OR?: Enumerable<FaunaParqueScalarWhereInput>
    NOT?: Enumerable<FaunaParqueScalarWhereInput>
    parqueId?: IntFilter | number
    faunaID?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type CategoriaParqueUpsertWithWhereUniqueWithoutParqueInput = {
    where: CategoriaParqueWhereUniqueInput
    update: XOR<CategoriaParqueUpdateWithoutParqueInput, CategoriaParqueUncheckedUpdateWithoutParqueInput>
    create: XOR<CategoriaParqueCreateWithoutParqueInput, CategoriaParqueUncheckedCreateWithoutParqueInput>
  }

  export type CategoriaParqueUpdateWithWhereUniqueWithoutParqueInput = {
    where: CategoriaParqueWhereUniqueInput
    data: XOR<CategoriaParqueUpdateWithoutParqueInput, CategoriaParqueUncheckedUpdateWithoutParqueInput>
  }

  export type CategoriaParqueUpdateManyWithWhereWithoutParqueInput = {
    where: CategoriaParqueScalarWhereInput
    data: XOR<CategoriaParqueUpdateManyMutationInput, CategoriaParqueUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type CategoriaParqueScalarWhereInput = {
    AND?: Enumerable<CategoriaParqueScalarWhereInput>
    OR?: Enumerable<CategoriaParqueScalarWhereInput>
    NOT?: Enumerable<CategoriaParqueScalarWhereInput>
    parqueId?: IntFilter | number
    categoriaId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type EstadoParqueUpsertWithWhereUniqueWithoutParqueInput = {
    where: EstadoParqueWhereUniqueInput
    update: XOR<EstadoParqueUpdateWithoutParqueInput, EstadoParqueUncheckedUpdateWithoutParqueInput>
    create: XOR<EstadoParqueCreateWithoutParqueInput, EstadoParqueUncheckedCreateWithoutParqueInput>
  }

  export type EstadoParqueUpdateWithWhereUniqueWithoutParqueInput = {
    where: EstadoParqueWhereUniqueInput
    data: XOR<EstadoParqueUpdateWithoutParqueInput, EstadoParqueUncheckedUpdateWithoutParqueInput>
  }

  export type EstadoParqueUpdateManyWithWhereWithoutParqueInput = {
    where: EstadoParqueScalarWhereInput
    data: XOR<EstadoParqueUpdateManyMutationInput, EstadoParqueUncheckedUpdateManyWithoutEstadoInput>
  }

  export type EstadoParqueScalarWhereInput = {
    AND?: Enumerable<EstadoParqueScalarWhereInput>
    OR?: Enumerable<EstadoParqueScalarWhereInput>
    NOT?: Enumerable<EstadoParqueScalarWhereInput>
    parqueId?: IntFilter | number
    estadoId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type RegionParqueUpsertWithWhereUniqueWithoutParqueInput = {
    where: RegionParqueWhereUniqueInput
    update: XOR<RegionParqueUpdateWithoutParqueInput, RegionParqueUncheckedUpdateWithoutParqueInput>
    create: XOR<RegionParqueCreateWithoutParqueInput, RegionParqueUncheckedCreateWithoutParqueInput>
  }

  export type RegionParqueUpdateWithWhereUniqueWithoutParqueInput = {
    where: RegionParqueWhereUniqueInput
    data: XOR<RegionParqueUpdateWithoutParqueInput, RegionParqueUncheckedUpdateWithoutParqueInput>
  }

  export type RegionParqueUpdateManyWithWhereWithoutParqueInput = {
    where: RegionParqueScalarWhereInput
    data: XOR<RegionParqueUpdateManyMutationInput, RegionParqueUncheckedUpdateManyWithoutRegionInput>
  }

  export type RegionParqueScalarWhereInput = {
    AND?: Enumerable<RegionParqueScalarWhereInput>
    OR?: Enumerable<RegionParqueScalarWhereInput>
    NOT?: Enumerable<RegionParqueScalarWhereInput>
    parqueId?: IntFilter | number
    regionId?: IntFilter | number
    assignedAt?: DateTimeFilter | Date | string
    assignedBy?: StringFilter | string
  }

  export type EstadoParqueCreateWithoutEstadoInput = {
    parque: ParqueCreateNestedOneWithoutEstadoInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueUncheckedCreateWithoutEstadoInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueCreateOrConnectWithoutEstadoInput = {
    where: EstadoParqueWhereUniqueInput
    create: XOR<EstadoParqueCreateWithoutEstadoInput, EstadoParqueUncheckedCreateWithoutEstadoInput>
  }

  export type EstadoParqueCreateManyEstadoInputEnvelope = {
    data: Enumerable<EstadoParqueCreateManyEstadoInput>
    skipDuplicates?: boolean
  }

  export type EstadoParqueUpsertWithWhereUniqueWithoutEstadoInput = {
    where: EstadoParqueWhereUniqueInput
    update: XOR<EstadoParqueUpdateWithoutEstadoInput, EstadoParqueUncheckedUpdateWithoutEstadoInput>
    create: XOR<EstadoParqueCreateWithoutEstadoInput, EstadoParqueUncheckedCreateWithoutEstadoInput>
  }

  export type EstadoParqueUpdateWithWhereUniqueWithoutEstadoInput = {
    where: EstadoParqueWhereUniqueInput
    data: XOR<EstadoParqueUpdateWithoutEstadoInput, EstadoParqueUncheckedUpdateWithoutEstadoInput>
  }

  export type EstadoParqueUpdateManyWithWhereWithoutEstadoInput = {
    where: EstadoParqueScalarWhereInput
    data: XOR<EstadoParqueUpdateManyMutationInput, EstadoParqueUncheckedUpdateManyWithoutParqueInput>
  }

  export type ParqueCreateWithoutEstadoInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutEstadoInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutEstadoInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutEstadoInput, ParqueUncheckedCreateWithoutEstadoInput>
  }

  export type EstadoCreateWithoutParqueInput = {
    nombre: string
  }

  export type EstadoUncheckedCreateWithoutParqueInput = {
    id?: number
    nombre: string
  }

  export type EstadoCreateOrConnectWithoutParqueInput = {
    where: EstadoWhereUniqueInput
    create: XOR<EstadoCreateWithoutParqueInput, EstadoUncheckedCreateWithoutParqueInput>
  }

  export type ParqueUpsertWithoutEstadoInput = {
    update: XOR<ParqueUpdateWithoutEstadoInput, ParqueUncheckedUpdateWithoutEstadoInput>
    create: XOR<ParqueCreateWithoutEstadoInput, ParqueUncheckedCreateWithoutEstadoInput>
  }

  export type ParqueUpdateWithoutEstadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutEstadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type EstadoUpsertWithoutParqueInput = {
    update: XOR<EstadoUpdateWithoutParqueInput, EstadoUncheckedUpdateWithoutParqueInput>
    create: XOR<EstadoCreateWithoutParqueInput, EstadoUncheckedCreateWithoutParqueInput>
  }

  export type EstadoUpdateWithoutParqueInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoUncheckedUpdateWithoutParqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueCreateWithoutRegionInput = {
    parque: ParqueCreateNestedOneWithoutRegionInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueUncheckedCreateWithoutRegionInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueCreateOrConnectWithoutRegionInput = {
    where: RegionParqueWhereUniqueInput
    create: XOR<RegionParqueCreateWithoutRegionInput, RegionParqueUncheckedCreateWithoutRegionInput>
  }

  export type RegionParqueCreateManyRegionInputEnvelope = {
    data: Enumerable<RegionParqueCreateManyRegionInput>
    skipDuplicates?: boolean
  }

  export type RegionParqueUpsertWithWhereUniqueWithoutRegionInput = {
    where: RegionParqueWhereUniqueInput
    update: XOR<RegionParqueUpdateWithoutRegionInput, RegionParqueUncheckedUpdateWithoutRegionInput>
    create: XOR<RegionParqueCreateWithoutRegionInput, RegionParqueUncheckedCreateWithoutRegionInput>
  }

  export type RegionParqueUpdateWithWhereUniqueWithoutRegionInput = {
    where: RegionParqueWhereUniqueInput
    data: XOR<RegionParqueUpdateWithoutRegionInput, RegionParqueUncheckedUpdateWithoutRegionInput>
  }

  export type RegionParqueUpdateManyWithWhereWithoutRegionInput = {
    where: RegionParqueScalarWhereInput
    data: XOR<RegionParqueUpdateManyMutationInput, RegionParqueUncheckedUpdateManyWithoutParqueInput>
  }

  export type ParqueCreateWithoutRegionInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutRegionInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutRegionInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutRegionInput, ParqueUncheckedCreateWithoutRegionInput>
  }

  export type RegionCreateWithoutParqueInput = {
    nombre: string
  }

  export type RegionUncheckedCreateWithoutParqueInput = {
    id?: number
    nombre: string
  }

  export type RegionCreateOrConnectWithoutParqueInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutParqueInput, RegionUncheckedCreateWithoutParqueInput>
  }

  export type ParqueUpsertWithoutRegionInput = {
    update: XOR<ParqueUpdateWithoutRegionInput, ParqueUncheckedUpdateWithoutRegionInput>
    create: XOR<ParqueCreateWithoutRegionInput, ParqueUncheckedCreateWithoutRegionInput>
  }

  export type ParqueUpdateWithoutRegionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type RegionUpsertWithoutParqueInput = {
    update: XOR<RegionUpdateWithoutParqueInput, RegionUncheckedUpdateWithoutParqueInput>
    create: XOR<RegionCreateWithoutParqueInput, RegionUncheckedCreateWithoutParqueInput>
  }

  export type RegionUpdateWithoutParqueInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateWithoutParqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueCreateWithoutCategoriaInput = {
    parque: ParqueCreateNestedOneWithoutCategoriaInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueUncheckedCreateWithoutCategoriaInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueCreateOrConnectWithoutCategoriaInput = {
    where: CategoriaParqueWhereUniqueInput
    create: XOR<CategoriaParqueCreateWithoutCategoriaInput, CategoriaParqueUncheckedCreateWithoutCategoriaInput>
  }

  export type CategoriaParqueCreateManyCategoriaInputEnvelope = {
    data: Enumerable<CategoriaParqueCreateManyCategoriaInput>
    skipDuplicates?: boolean
  }

  export type CategoriaParqueUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: CategoriaParqueWhereUniqueInput
    update: XOR<CategoriaParqueUpdateWithoutCategoriaInput, CategoriaParqueUncheckedUpdateWithoutCategoriaInput>
    create: XOR<CategoriaParqueCreateWithoutCategoriaInput, CategoriaParqueUncheckedCreateWithoutCategoriaInput>
  }

  export type CategoriaParqueUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: CategoriaParqueWhereUniqueInput
    data: XOR<CategoriaParqueUpdateWithoutCategoriaInput, CategoriaParqueUncheckedUpdateWithoutCategoriaInput>
  }

  export type CategoriaParqueUpdateManyWithWhereWithoutCategoriaInput = {
    where: CategoriaParqueScalarWhereInput
    data: XOR<CategoriaParqueUpdateManyMutationInput, CategoriaParqueUncheckedUpdateManyWithoutParqueInput>
  }

  export type ParqueCreateWithoutCategoriaInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutCategoriaInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutCategoriaInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutCategoriaInput, ParqueUncheckedCreateWithoutCategoriaInput>
  }

  export type CategoriaCreateWithoutParqueInput = {
    nombre: string
  }

  export type CategoriaUncheckedCreateWithoutParqueInput = {
    id?: number
    nombre: string
  }

  export type CategoriaCreateOrConnectWithoutParqueInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutParqueInput, CategoriaUncheckedCreateWithoutParqueInput>
  }

  export type ParqueUpsertWithoutCategoriaInput = {
    update: XOR<ParqueUpdateWithoutCategoriaInput, ParqueUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ParqueCreateWithoutCategoriaInput, ParqueUncheckedCreateWithoutCategoriaInput>
  }

  export type ParqueUpdateWithoutCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type CategoriaUpsertWithoutParqueInput = {
    update: XOR<CategoriaUpdateWithoutParqueInput, CategoriaUncheckedUpdateWithoutParqueInput>
    create: XOR<CategoriaCreateWithoutParqueInput, CategoriaUncheckedCreateWithoutParqueInput>
  }

  export type CategoriaUpdateWithoutParqueInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateWithoutParqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueCreateWithoutFloraInput = {
    parque: ParqueCreateNestedOneWithoutFloraInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueUncheckedCreateWithoutFloraInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueCreateOrConnectWithoutFloraInput = {
    where: FloraParqueWhereUniqueInput
    create: XOR<FloraParqueCreateWithoutFloraInput, FloraParqueUncheckedCreateWithoutFloraInput>
  }

  export type FloraParqueCreateManyFloraInputEnvelope = {
    data: Enumerable<FloraParqueCreateManyFloraInput>
    skipDuplicates?: boolean
  }

  export type FloraParqueUpsertWithWhereUniqueWithoutFloraInput = {
    where: FloraParqueWhereUniqueInput
    update: XOR<FloraParqueUpdateWithoutFloraInput, FloraParqueUncheckedUpdateWithoutFloraInput>
    create: XOR<FloraParqueCreateWithoutFloraInput, FloraParqueUncheckedCreateWithoutFloraInput>
  }

  export type FloraParqueUpdateWithWhereUniqueWithoutFloraInput = {
    where: FloraParqueWhereUniqueInput
    data: XOR<FloraParqueUpdateWithoutFloraInput, FloraParqueUncheckedUpdateWithoutFloraInput>
  }

  export type FloraParqueUpdateManyWithWhereWithoutFloraInput = {
    where: FloraParqueScalarWhereInput
    data: XOR<FloraParqueUpdateManyMutationInput, FloraParqueUncheckedUpdateManyWithoutParquesInput>
  }

  export type ParqueCreateWithoutFloraInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutFloraInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutFloraInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutFloraInput, ParqueUncheckedCreateWithoutFloraInput>
  }

  export type FloraCreateWithoutParquesInput = {
    nombre: string
    imagen: string
    descripcion: string
  }

  export type FloraUncheckedCreateWithoutParquesInput = {
    id?: number
    nombre: string
    imagen: string
    descripcion: string
  }

  export type FloraCreateOrConnectWithoutParquesInput = {
    where: FloraWhereUniqueInput
    create: XOR<FloraCreateWithoutParquesInput, FloraUncheckedCreateWithoutParquesInput>
  }

  export type ParqueUpsertWithoutFloraInput = {
    update: XOR<ParqueUpdateWithoutFloraInput, ParqueUncheckedUpdateWithoutFloraInput>
    create: XOR<ParqueCreateWithoutFloraInput, ParqueUncheckedCreateWithoutFloraInput>
  }

  export type ParqueUpdateWithoutFloraInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutFloraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type FloraUpsertWithoutParquesInput = {
    update: XOR<FloraUpdateWithoutParquesInput, FloraUncheckedUpdateWithoutParquesInput>
    create: XOR<FloraCreateWithoutParquesInput, FloraUncheckedCreateWithoutParquesInput>
  }

  export type FloraUpdateWithoutParquesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FloraUncheckedUpdateWithoutParquesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueCreateWithoutFaunaInput = {
    parque: ParqueCreateNestedOneWithoutFaunaInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueUncheckedCreateWithoutFaunaInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueCreateOrConnectWithoutFaunaInput = {
    where: FaunaParqueWhereUniqueInput
    create: XOR<FaunaParqueCreateWithoutFaunaInput, FaunaParqueUncheckedCreateWithoutFaunaInput>
  }

  export type FaunaParqueCreateManyFaunaInputEnvelope = {
    data: Enumerable<FaunaParqueCreateManyFaunaInput>
    skipDuplicates?: boolean
  }

  export type FaunaParqueUpsertWithWhereUniqueWithoutFaunaInput = {
    where: FaunaParqueWhereUniqueInput
    update: XOR<FaunaParqueUpdateWithoutFaunaInput, FaunaParqueUncheckedUpdateWithoutFaunaInput>
    create: XOR<FaunaParqueCreateWithoutFaunaInput, FaunaParqueUncheckedCreateWithoutFaunaInput>
  }

  export type FaunaParqueUpdateWithWhereUniqueWithoutFaunaInput = {
    where: FaunaParqueWhereUniqueInput
    data: XOR<FaunaParqueUpdateWithoutFaunaInput, FaunaParqueUncheckedUpdateWithoutFaunaInput>
  }

  export type FaunaParqueUpdateManyWithWhereWithoutFaunaInput = {
    where: FaunaParqueScalarWhereInput
    data: XOR<FaunaParqueUpdateManyMutationInput, FaunaParqueUncheckedUpdateManyWithoutParquesInput>
  }

  export type ParqueCreateWithoutFaunaInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutFaunaInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutFaunaInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutFaunaInput, ParqueUncheckedCreateWithoutFaunaInput>
  }

  export type FaunaCreateWithoutParquesInput = {
    nombre: string
    imagen: string
    descripcion: string
  }

  export type FaunaUncheckedCreateWithoutParquesInput = {
    id?: number
    nombre: string
    imagen: string
    descripcion: string
  }

  export type FaunaCreateOrConnectWithoutParquesInput = {
    where: FaunaWhereUniqueInput
    create: XOR<FaunaCreateWithoutParquesInput, FaunaUncheckedCreateWithoutParquesInput>
  }

  export type ParqueUpsertWithoutFaunaInput = {
    update: XOR<ParqueUpdateWithoutFaunaInput, ParqueUncheckedUpdateWithoutFaunaInput>
    create: XOR<ParqueCreateWithoutFaunaInput, ParqueUncheckedCreateWithoutFaunaInput>
  }

  export type ParqueUpdateWithoutFaunaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutFaunaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type FaunaUpsertWithoutParquesInput = {
    update: XOR<FaunaUpdateWithoutParquesInput, FaunaUncheckedUpdateWithoutParquesInput>
    create: XOR<FaunaCreateWithoutParquesInput, FaunaUncheckedCreateWithoutParquesInput>
  }

  export type FaunaUpdateWithoutParquesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaUncheckedUpdateWithoutParquesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueCreateWithoutActividadInput = {
    parque: ParqueCreateNestedOneWithoutActividadesInput
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueUncheckedCreateWithoutActividadInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueCreateOrConnectWithoutActividadInput = {
    where: ActividadParqueWhereUniqueInput
    create: XOR<ActividadParqueCreateWithoutActividadInput, ActividadParqueUncheckedCreateWithoutActividadInput>
  }

  export type ActividadParqueCreateManyActividadInputEnvelope = {
    data: Enumerable<ActividadParqueCreateManyActividadInput>
    skipDuplicates?: boolean
  }

  export type ActividadParqueUpsertWithWhereUniqueWithoutActividadInput = {
    where: ActividadParqueWhereUniqueInput
    update: XOR<ActividadParqueUpdateWithoutActividadInput, ActividadParqueUncheckedUpdateWithoutActividadInput>
    create: XOR<ActividadParqueCreateWithoutActividadInput, ActividadParqueUncheckedCreateWithoutActividadInput>
  }

  export type ActividadParqueUpdateWithWhereUniqueWithoutActividadInput = {
    where: ActividadParqueWhereUniqueInput
    data: XOR<ActividadParqueUpdateWithoutActividadInput, ActividadParqueUncheckedUpdateWithoutActividadInput>
  }

  export type ActividadParqueUpdateManyWithWhereWithoutActividadInput = {
    where: ActividadParqueScalarWhereInput
    data: XOR<ActividadParqueUpdateManyMutationInput, ActividadParqueUncheckedUpdateManyWithoutParquesInput>
  }

  export type ParqueCreateWithoutActividadesInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    horario?: HorarioCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutActividadesInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutActividadesInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutActividadesInput, ParqueUncheckedCreateWithoutActividadesInput>
  }

  export type ActividadCreateWithoutParquesInput = {
    nombre: string
  }

  export type ActividadUncheckedCreateWithoutParquesInput = {
    id?: number
    nombre: string
  }

  export type ActividadCreateOrConnectWithoutParquesInput = {
    where: ActividadWhereUniqueInput
    create: XOR<ActividadCreateWithoutParquesInput, ActividadUncheckedCreateWithoutParquesInput>
  }

  export type ParqueUpsertWithoutActividadesInput = {
    update: XOR<ParqueUpdateWithoutActividadesInput, ParqueUncheckedUpdateWithoutActividadesInput>
    create: XOR<ParqueCreateWithoutActividadesInput, ParqueUncheckedCreateWithoutActividadesInput>
  }

  export type ParqueUpdateWithoutActividadesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    horario?: HorarioUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutActividadesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type ActividadUpsertWithoutParquesInput = {
    update: XOR<ActividadUpdateWithoutParquesInput, ActividadUncheckedUpdateWithoutParquesInput>
    create: XOR<ActividadCreateWithoutParquesInput, ActividadUncheckedCreateWithoutParquesInput>
  }

  export type ActividadUpdateWithoutParquesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadUncheckedUpdateWithoutParquesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ParqueCreateWithoutAnunciosInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    horario?: HorarioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutAnunciosInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    horario?: HorarioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutAnunciosInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutAnunciosInput, ParqueUncheckedCreateWithoutAnunciosInput>
  }

  export type ParqueUpsertWithoutAnunciosInput = {
    update: XOR<ParqueUpdateWithoutAnunciosInput, ParqueUncheckedUpdateWithoutAnunciosInput>
    create: XOR<ParqueCreateWithoutAnunciosInput, ParqueUncheckedCreateWithoutAnunciosInput>
  }

  export type ParqueUpdateWithoutAnunciosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    horario?: HorarioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutAnunciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    horario?: HorarioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type ParqueCreateWithoutHorarioInput = {
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueCreateNestedManyWithoutParqueInput
    flora?: FloraParqueCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueCreateNestedManyWithoutParqueInput
    region?: RegionParqueCreateNestedManyWithoutParqueInput
  }

  export type ParqueUncheckedCreateWithoutHorarioInput = {
    id?: number
    nombre: string
    descripcion: string
    imagen: string
    direccion: string
    latitud: number
    longitud: number
    fechaDecreto: string
    superficieTerrestre: number
    superficieMarina: number
    clicks: number
    anuncios?: AnuncioUncheckedCreateNestedManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedCreateNestedManyWithoutParqueInput
    flora?: FloraParqueUncheckedCreateNestedManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedCreateNestedManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedCreateNestedManyWithoutParqueInput
    estado?: EstadoParqueUncheckedCreateNestedManyWithoutParqueInput
    region?: RegionParqueUncheckedCreateNestedManyWithoutParqueInput
  }

  export type ParqueCreateOrConnectWithoutHorarioInput = {
    where: ParqueWhereUniqueInput
    create: XOR<ParqueCreateWithoutHorarioInput, ParqueUncheckedCreateWithoutHorarioInput>
  }

  export type ParqueUpsertWithoutHorarioInput = {
    update: XOR<ParqueUpdateWithoutHorarioInput, ParqueUncheckedUpdateWithoutHorarioInput>
    create: XOR<ParqueCreateWithoutHorarioInput, ParqueUncheckedCreateWithoutHorarioInput>
  }

  export type ParqueUpdateWithoutHorarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUpdateManyWithoutParqueInput
    flora?: FloraParqueUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUpdateManyWithoutParqueInput
    estado?: EstadoParqueUpdateManyWithoutParqueInput
    region?: RegionParqueUpdateManyWithoutParqueInput
  }

  export type ParqueUncheckedUpdateWithoutHorarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    latitud?: FloatFieldUpdateOperationsInput | number
    longitud?: FloatFieldUpdateOperationsInput | number
    fechaDecreto?: StringFieldUpdateOperationsInput | string
    superficieTerrestre?: FloatFieldUpdateOperationsInput | number
    superficieMarina?: FloatFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    anuncios?: AnuncioUncheckedUpdateManyWithoutParqueInput
    actividades?: ActividadParqueUncheckedUpdateManyWithoutParqueInput
    flora?: FloraParqueUncheckedUpdateManyWithoutParqueInput
    fauna?: FaunaParqueUncheckedUpdateManyWithoutParqueInput
    categoria?: CategoriaParqueUncheckedUpdateManyWithoutParqueInput
    estado?: EstadoParqueUncheckedUpdateManyWithoutParqueInput
    region?: RegionParqueUncheckedUpdateManyWithoutParqueInput
  }

  export type AnuncioCreateManyParqueInput = {
    id?: number
    titulo: string
    descripcion: string
    variante: string
  }

  export type HorarioCreateManyParqueInput = {
    id?: number
    dias: string
    horaAbrir: string
    horaCerrar: string
  }

  export type ActividadParqueCreateManyParqueInput = {
    actividadId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueCreateManyParqueInput = {
    floraId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueCreateManyParqueInput = {
    faunaID: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueCreateManyParqueInput = {
    categoriaId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueCreateManyParqueInput = {
    estadoId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueCreateManyParqueInput = {
    regionId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type AnuncioUpdateWithoutParqueInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
  }

  export type AnuncioUncheckedUpdateWithoutParqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
  }

  export type AnuncioUncheckedUpdateManyWithoutAnunciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    variante?: StringFieldUpdateOperationsInput | string
  }

  export type HorarioUpdateWithoutParqueInput = {
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
  }

  export type HorarioUncheckedUpdateWithoutParqueInput = {
    id?: IntFieldUpdateOperationsInput | number
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
  }

  export type HorarioUncheckedUpdateManyWithoutHorarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    dias?: StringFieldUpdateOperationsInput | string
    horaAbrir?: StringFieldUpdateOperationsInput | string
    horaCerrar?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUpdateWithoutParqueInput = {
    actividad?: ActividadUpdateOneRequiredWithoutParquesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUncheckedUpdateWithoutParqueInput = {
    actividadId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUncheckedUpdateManyWithoutActividadesInput = {
    actividadId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueUpdateWithoutParqueInput = {
    flora?: FloraUpdateOneRequiredWithoutParquesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueUncheckedUpdateWithoutParqueInput = {
    floraId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueUpdateWithoutParqueInput = {
    fauna?: FaunaUpdateOneRequiredWithoutParquesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueUncheckedUpdateWithoutParqueInput = {
    faunaID?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueUpdateWithoutParqueInput = {
    categoria?: CategoriaUpdateOneRequiredWithoutParqueInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueUncheckedUpdateWithoutParqueInput = {
    categoriaId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueUpdateWithoutParqueInput = {
    estado?: EstadoUpdateOneRequiredWithoutParqueInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueUncheckedUpdateWithoutParqueInput = {
    estadoId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueUpdateWithoutParqueInput = {
    region?: RegionUpdateOneRequiredWithoutParqueInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueUncheckedUpdateWithoutParqueInput = {
    regionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueCreateManyEstadoInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type EstadoParqueUpdateWithoutEstadoInput = {
    parque?: ParqueUpdateOneRequiredWithoutEstadoInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type EstadoParqueUncheckedUpdateWithoutEstadoInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueCreateManyRegionInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type RegionParqueUpdateWithoutRegionInput = {
    parque?: ParqueUpdateOneRequiredWithoutRegionInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type RegionParqueUncheckedUpdateWithoutRegionInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueCreateManyCategoriaInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type CategoriaParqueUpdateWithoutCategoriaInput = {
    parque?: ParqueUpdateOneRequiredWithoutCategoriaInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaParqueUncheckedUpdateWithoutCategoriaInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueCreateManyFloraInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FloraParqueUpdateWithoutFloraInput = {
    parque?: ParqueUpdateOneRequiredWithoutFloraInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueUncheckedUpdateWithoutFloraInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FloraParqueUncheckedUpdateManyWithoutParquesInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueCreateManyFaunaInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type FaunaParqueUpdateWithoutFaunaInput = {
    parque?: ParqueUpdateOneRequiredWithoutFaunaInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueUncheckedUpdateWithoutFaunaInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FaunaParqueUncheckedUpdateManyWithoutParquesInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueCreateManyActividadInput = {
    parqueId: number
    assignedAt?: Date | string
    assignedBy: string
  }

  export type ActividadParqueUpdateWithoutActividadInput = {
    parque?: ParqueUpdateOneRequiredWithoutActividadesInput
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUncheckedUpdateWithoutActividadInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ActividadParqueUncheckedUpdateManyWithoutParquesInput = {
    parqueId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}